# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package ZNC;
use base qw(Exporter);
use base qw(DynaLoader);
package ZNCc;
bootstrap ZNC;
package ZNC;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package ZNC;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package ZNC;

*SetFdCloseOnExec = *ZNCc::SetFdCloseOnExec;
*GetAddrInfo = *ZNCc::GetAddrInfo;
*GetCsockClassIdx = *ZNCc::GetCsockClassIdx;
*InitCsocket = *ZNCc::InitCsocket;
*ShutdownCsocket = *ZNCc::ShutdownCsocket;
*GetSockError = *ZNCc::GetSockError;
*TFD_ZERO = *ZNCc::TFD_ZERO;
*TFD_SET = *ZNCc::TFD_SET;
*TFD_ISSET = *ZNCc::TFD_ISSET;
*TFD_CLR = *ZNCc::TFD_CLR;
*__Perror = *ZNCc::__Perror;
*millitime = *ZNCc::millitime;
*AsPerlModule = *ZNCc::AsPerlModule;
*CreatePerlTimer = *ZNCc::CreatePerlTimer;
*CreatePerlSocket = *ZNCc::CreatePerlSocket;
*HaveIPv6 = *ZNCc::HaveIPv6;
*HaveSSL = *ZNCc::HaveSSL;
*_GetSOMAXCONN = *ZNCc::_GetSOMAXCONN;
*GetVersionMajor = *ZNCc::GetVersionMajor;
*GetVersionMinor = *ZNCc::GetVersionMinor;
*GetVersion = *ZNCc::GetVersion;
*GetVersionExtra = *ZNCc::GetVersionExtra;
*_VPair_Add2Str = *ZNCc::_VPair_Add2Str;
*_CreateWebSubPage = *ZNCc::_CreateWebSubPage;
*_CleanupStash = *ZNCc::_CleanupStash;

############# Class : ZNC::CString ##############

package ZNC::CString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CString(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::_stringlist ##############

package ZNC::_stringlist;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new__stringlist(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::_stringlist_size;
*empty = *ZNCc::_stringlist_empty;
*clear = *ZNCc::_stringlist_clear;
*push = *ZNCc::_stringlist_push;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete__stringlist($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::VIRCNetworks ##############

package ZNC::VIRCNetworks;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_VIRCNetworks(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::VIRCNetworks_size;
*empty = *ZNCc::VIRCNetworks_empty;
*clear = *ZNCc::VIRCNetworks_clear;
*push = *ZNCc::VIRCNetworks_push;
*pop = *ZNCc::VIRCNetworks_pop;
*get = *ZNCc::VIRCNetworks_get;
*set = *ZNCc::VIRCNetworks_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_VIRCNetworks($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::VChannels ##############

package ZNC::VChannels;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_VChannels(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::VChannels_size;
*empty = *ZNCc::VChannels_empty;
*clear = *ZNCc::VChannels_clear;
*push = *ZNCc::VChannels_push;
*pop = *ZNCc::VChannels_pop;
*get = *ZNCc::VChannels_get;
*set = *ZNCc::VChannels_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_VChannels($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::VCString ##############

package ZNC::VCString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_VCString(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::VCString_size;
*empty = *ZNCc::VCString_empty;
*clear = *ZNCc::VCString_clear;
*push = *ZNCc::VCString_push;
*pop = *ZNCc::VCString_pop;
*get = *ZNCc::VCString_get;
*set = *ZNCc::VCString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_VCString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::PerlMCString ##############

package ZNC::PerlMCString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_PerlMCString(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::PerlMCString_size;
*empty = *ZNCc::PerlMCString_empty;
*clear = *ZNCc::PerlMCString_clear;
*get = *ZNCc::PerlMCString_get;
*set = *ZNCc::PerlMCString_set;
*del = *ZNCc::PerlMCString_del;
*has_key = *ZNCc::PerlMCString_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_PerlMCString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::MCString ##############

package ZNC::MCString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::PerlMCString ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_MCString(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_MCString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::VListeners ##############

package ZNC::VListeners;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_VListeners(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::VListeners_size;
*empty = *ZNCc::VListeners_empty;
*clear = *ZNCc::VListeners_clear;
*push = *ZNCc::VListeners_push;
*pop = *ZNCc::VListeners_pop;
*get = *ZNCc::VListeners_get;
*set = *ZNCc::VListeners_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_VListeners($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::BufLines ##############

package ZNC::BufLines;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
*empty = *ZNCc::BufLines_empty;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_BufLines(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_BufLines($self);
        delete $OWNER{$self};
    }
}

*assign = *ZNCc::BufLines_assign;
*swap = *ZNCc::BufLines_swap;
*size = *ZNCc::BufLines_size;
*max_size = *ZNCc::BufLines_max_size;
*resize = *ZNCc::BufLines_resize;
*front = *ZNCc::BufLines_front;
*back = *ZNCc::BufLines_back;
*push_front = *ZNCc::BufLines_push_front;
*push_back = *ZNCc::BufLines_push_back;
*pop_front = *ZNCc::BufLines_pop_front;
*pop_back = *ZNCc::BufLines_pop_back;
*clear = *ZNCc::BufLines_clear;
*getitem = *ZNCc::BufLines_getitem;
*setitem = *ZNCc::BufLines_setitem;
*delitem = *ZNCc::BufLines_delitem;
*getslice = *ZNCc::BufLines_getslice;
*setslice = *ZNCc::BufLines_setslice;
*delslice = *ZNCc::BufLines_delslice;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::VVString ##############

package ZNC::VVString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_VVString(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::VVString_size;
*empty = *ZNCc::VVString_empty;
*clear = *ZNCc::VVString_clear;
*push = *ZNCc::VVString_push;
*pop = *ZNCc::VVString_pop;
*get = *ZNCc::VVString_get;
*set = *ZNCc::VVString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_VVString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CUtils ##############

package ZNC::CUtils;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CUtils(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CUtils($self);
        delete $OWNER{$self};
    }
}

*GetIP = *ZNCc::CUtils_GetIP;
*GetLongIP = *ZNCc::CUtils_GetLongIP;
*PrintError = *ZNCc::CUtils_PrintError;
*PrintMessage = *ZNCc::CUtils_PrintMessage;
*PrintPrompt = *ZNCc::CUtils_PrintPrompt;
*PrintAction = *ZNCc::CUtils_PrintAction;
*PrintStatus = *ZNCc::CUtils_PrintStatus;
*GetSaltedHashPass = *ZNCc::CUtils_GetSaltedHashPass;
*GetSalt = *ZNCc::CUtils_GetSalt;
*SaltedMD5Hash = *ZNCc::CUtils_SaltedMD5Hash;
*SaltedSHA256Hash = *ZNCc::CUtils_SaltedSHA256Hash;
*GetPass = *ZNCc::CUtils_GetPass;
*GetInput = *ZNCc::CUtils_GetInput;
*GetBoolInput = *ZNCc::CUtils_GetBoolInput;
*GetNumInput = *ZNCc::CUtils_GetNumInput;
*GetMillTime = *ZNCc::CUtils_GetMillTime;
*CTime = *ZNCc::CUtils_CTime;
*FormatTime = *ZNCc::CUtils_FormatTime;
*GetTimezones = *ZNCc::CUtils_GetTimezones;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CException ##############

package ZNC::CException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
*EX_Shutdown = *ZNCc::CException_EX_Shutdown;
*EX_Restart = *ZNCc::CException_EX_Restart;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CException($self);
        delete $OWNER{$self};
    }
}

*GetType = *ZNCc::CException_GetType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CTable ##############

package ZNC::CTable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CTable(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CTable($self);
        delete $OWNER{$self};
    }
}

*AddColumn = *ZNCc::CTable_AddColumn;
*AddRow = *ZNCc::CTable_AddRow;
*SetCell = *ZNCc::CTable_SetCell;
*GetLine = *ZNCc::CTable_GetLine;
*GetColumnWidth = *ZNCc::CTable_GetColumnWidth;
*Clear = *ZNCc::CTable_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CConfigEntry ##############

package ZNC::CConfigEntry;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CConfigEntry(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CConfigEntry($self);
        delete $OWNER{$self};
    }
}

*swig_m_pSubConfig_get = *ZNCc::CConfigEntry_m_pSubConfig_get;
*swig_m_pSubConfig_set = *ZNCc::CConfigEntry_m_pSubConfig_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CConfig ##############

package ZNC::CConfig;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
*BeginEntries = *ZNCc::CConfig_BeginEntries;
*EndEntries = *ZNCc::CConfig_EndEntries;
*BeginSubConfigs = *ZNCc::CConfig_BeginSubConfigs;
*EndSubConfigs = *ZNCc::CConfig_EndSubConfigs;
*AddKeyValuePair = *ZNCc::CConfig_AddKeyValuePair;
*AddSubConfig = *ZNCc::CConfig_AddSubConfig;
*FindStringVector = *ZNCc::CConfig_FindStringVector;
*FindStringEntry = *ZNCc::CConfig_FindStringEntry;
*FindBoolEntry = *ZNCc::CConfig_FindBoolEntry;
*FindUIntEntry = *ZNCc::CConfig_FindUIntEntry;
*FindUShortEntry = *ZNCc::CConfig_FindUShortEntry;
*FindDoubleEntry = *ZNCc::CConfig_FindDoubleEntry;
*FindSubConfig = *ZNCc::CConfig_FindSubConfig;
*empty = *ZNCc::CConfig_empty;
*Parse = *ZNCc::CConfig_Parse;
*Write = *ZNCc::CConfig_Write;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CConfig(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CConfig($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSCharBuffer ##############

package ZNC::CSCharBuffer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSCharBuffer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSCharBuffer($self);
        delete $OWNER{$self};
    }
}

*__call__ = *ZNCc::CSCharBuffer___call__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSSockAddr ##############

package ZNC::CSSockAddr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSSockAddr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSSockAddr($self);
        delete $OWNER{$self};
    }
}

*RAF_ANY = *ZNCc::CSSockAddr_RAF_ANY;
*RAF_INET = *ZNCc::CSSockAddr_RAF_INET;
*SinFamily = *ZNCc::CSSockAddr_SinFamily;
*SinPort = *ZNCc::CSSockAddr_SinPort;
*SetIPv6 = *ZNCc::CSSockAddr_SetIPv6;
*GetIPv6 = *ZNCc::CSSockAddr_GetIPv6;
*GetSockAddrLen = *ZNCc::CSSockAddr_GetSockAddrLen;
*GetSockAddr = *ZNCc::CSSockAddr_GetSockAddr;
*GetAddr = *ZNCc::CSSockAddr_GetAddr;
*SetAFRequire = *ZNCc::CSSockAddr_SetAFRequire;
*GetAFRequire = *ZNCc::CSSockAddr_GetAFRequire;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CGetAddrInfo ##############

package ZNC::CGetAddrInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CGetAddrInfo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CGetAddrInfo($self);
        delete $OWNER{$self};
    }
}

*Init = *ZNCc::CGetAddrInfo_Init;
*Process = *ZNCc::CGetAddrInfo_Process;
*Finish = *ZNCc::CGetAddrInfo_Finish;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CCron ##############

package ZNC::CCron;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CCron(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CCron($self);
        delete $OWNER{$self};
    }
}

*run = *ZNCc::CCron_run;
*StartMaxCycles = *ZNCc::CCron_StartMaxCycles;
*Start = *ZNCc::CCron_Start;
*Stop = *ZNCc::CCron_Stop;
*Pause = *ZNCc::CCron_Pause;
*UnPause = *ZNCc::CCron_UnPause;
*GetInterval = *ZNCc::CCron_GetInterval;
*GetMaxCycles = *ZNCc::CCron_GetMaxCycles;
*GetCyclesLeft = *ZNCc::CCron_GetCyclesLeft;
*isValid = *ZNCc::CCron_isValid;
*GetName = *ZNCc::CCron_GetName;
*SetName = *ZNCc::CCron_SetName;
*GetNextRun = *ZNCc::CCron_GetNextRun;
*RunJob = *ZNCc::CCron_RunJob;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSMonitorFD ##############

package ZNC::CSMonitorFD;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSMonitorFD(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSMonitorFD($self);
        delete $OWNER{$self};
    }
}

*GatherFDsForSelect = *ZNCc::CSMonitorFD_GatherFDsForSelect;
*FDsThatTriggered = *ZNCc::CSMonitorFD_FDsThatTriggered;
*CheckFDs = *ZNCc::CSMonitorFD_CheckFDs;
*Add = *ZNCc::CSMonitorFD_Add;
*Remove = *ZNCc::CSMonitorFD_Remove;
*DisableMonitor = *ZNCc::CSMonitorFD_DisableMonitor;
*IsEnabled = *ZNCc::CSMonitorFD_IsEnabled;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSockCommon ##############

package ZNC::CSockCommon;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSockCommon(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSockCommon($self);
        delete $OWNER{$self};
    }
}

*CleanupCrons = *ZNCc::CSockCommon_CleanupCrons;
*CleanupFDMonitors = *ZNCc::CSockCommon_CleanupFDMonitors;
*GetCrons = *ZNCc::CSockCommon_GetCrons;
*Cron = *ZNCc::CSockCommon_Cron;
*AddCron = *ZNCc::CSockCommon_AddCron;
*DelCron = *ZNCc::CSockCommon_DelCron;
*DelCronByAddr = *ZNCc::CSockCommon_DelCronByAddr;
*CheckFDs = *ZNCc::CSockCommon_CheckFDs;
*AssignFDs = *ZNCc::CSockCommon_AssignFDs;
*MonitorFD = *ZNCc::CSockCommon_MonitorFD;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::Csock ##############

package ZNC::Csock;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CSockCommon ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_Csock(@_);
    bless $self, $pkg if defined($self);
}

*GetSockObj = *ZNCc::Csock_GetSockObj;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_Csock($self);
        delete $OWNER{$self};
    }
}

*Dereference = *ZNCc::Csock_Dereference;
*Copy = *ZNCc::Csock_Copy;
*OUTBOUND = *ZNCc::Csock_OUTBOUND;
*LISTENER = *ZNCc::Csock_LISTENER;
*INBOUND = *ZNCc::Csock_INBOUND;
*READ_EOF = *ZNCc::Csock_READ_EOF;
*READ_ERR = *ZNCc::Csock_READ_ERR;
*READ_EAGAIN = *ZNCc::Csock_READ_EAGAIN;
*READ_CONNREFUSED = *ZNCc::Csock_READ_CONNREFUSED;
*READ_TIMEDOUT = *ZNCc::Csock_READ_TIMEDOUT;
*SEL_OK = *ZNCc::Csock_SEL_OK;
*SEL_TIMEOUT = *ZNCc::Csock_SEL_TIMEOUT;
*SEL_EAGAIN = *ZNCc::Csock_SEL_EAGAIN;
*SEL_ERR = *ZNCc::Csock_SEL_ERR;
*SSL23 = *ZNCc::Csock_SSL23;
*SSL2 = *ZNCc::Csock_SSL2;
*SSL3 = *ZNCc::Csock_SSL3;
*TLS1 = *ZNCc::Csock_TLS1;
*CST_START = *ZNCc::Csock_CST_START;
*CST_DNS = *ZNCc::Csock_CST_DNS;
*CST_BINDVHOST = *ZNCc::Csock_CST_BINDVHOST;
*CST_DESTDNS = *ZNCc::Csock_CST_DESTDNS;
*CST_CONNECT = *ZNCc::Csock_CST_CONNECT;
*CST_CONNECTSSL = *ZNCc::Csock_CST_CONNECTSSL;
*CST_OK = *ZNCc::Csock_CST_OK;
*CLT_DONT = *ZNCc::Csock_CLT_DONT;
*CLT_NOW = *ZNCc::Csock_CLT_NOW;
*CLT_AFTERWRITE = *ZNCc::Csock_CLT_AFTERWRITE;
*CLT_DEREFERENCE = *ZNCc::Csock_CLT_DEREFERENCE;
*__lshift__ = *ZNCc::Csock___lshift__;
*Connect = *ZNCc::Csock_Connect;
*Listen = *ZNCc::Csock_Listen;
*Accept = *ZNCc::Csock_Accept;
*AcceptSSL = *ZNCc::Csock_AcceptSSL;
*SSLClientSetup = *ZNCc::Csock_SSLClientSetup;
*SSLServerSetup = *ZNCc::Csock_SSLServerSetup;
*ConnectSSL = *ZNCc::Csock_ConnectSSL;
*StartTLS = *ZNCc::Csock_StartTLS;
*Write = *ZNCc::Csock_Write;
*Read = *ZNCc::Csock_Read;
*GetLocalIP = *ZNCc::Csock_GetLocalIP;
*GetRemoteIP = *ZNCc::Csock_GetRemoteIP;
*IsConnected = *ZNCc::Csock_IsConnected;
*SetIsConnected = *ZNCc::Csock_SetIsConnected;
*GetRSock = *ZNCc::Csock_GetRSock;
*SetRSock = *ZNCc::Csock_SetRSock;
*GetWSock = *ZNCc::Csock_GetWSock;
*SetWSock = *ZNCc::Csock_SetWSock;
*SetSock = *ZNCc::Csock_SetSock;
*GetSock = *ZNCc::Csock_GetSock;
*CallSockError = *ZNCc::Csock_CallSockError;
*ResetTimer = *ZNCc::Csock_ResetTimer;
*PauseRead = *ZNCc::Csock_PauseRead;
*UnPauseRead = *ZNCc::Csock_UnPauseRead;
*IsReadPaused = *ZNCc::Csock_IsReadPaused;
*TMO_READ = *ZNCc::Csock_TMO_READ;
*TMO_WRITE = *ZNCc::Csock_TMO_WRITE;
*TMO_ACCEPT = *ZNCc::Csock_TMO_ACCEPT;
*TMO_ALL = *ZNCc::Csock_TMO_ALL;
*SetTimeout = *ZNCc::Csock_SetTimeout;
*SetTimeoutType = *ZNCc::Csock_SetTimeoutType;
*GetTimeout = *ZNCc::Csock_GetTimeout;
*GetTimeoutType = *ZNCc::Csock_GetTimeoutType;
*CheckTimeout = *ZNCc::Csock_CheckTimeout;
*PushBuff = *ZNCc::Csock_PushBuff;
*GetInternalReadBuffer = *ZNCc::Csock_GetInternalReadBuffer;
*GetInternalWriteBuffer = *ZNCc::Csock_GetInternalWriteBuffer;
*SetMaxBufferThreshold = *ZNCc::Csock_SetMaxBufferThreshold;
*GetMaxBufferThreshold = *ZNCc::Csock_GetMaxBufferThreshold;
*GetType = *ZNCc::Csock_GetType;
*SetType = *ZNCc::Csock_SetType;
*GetSockName = *ZNCc::Csock_GetSockName;
*SetSockName = *ZNCc::Csock_SetSockName;
*GetHostName = *ZNCc::Csock_GetHostName;
*SetHostName = *ZNCc::Csock_SetHostName;
*GetStartTime = *ZNCc::Csock_GetStartTime;
*ResetStartTime = *ZNCc::Csock_ResetStartTime;
*GetBytesRead = *ZNCc::Csock_GetBytesRead;
*ResetBytesRead = *ZNCc::Csock_ResetBytesRead;
*GetBytesWritten = *ZNCc::Csock_GetBytesWritten;
*ResetBytesWritten = *ZNCc::Csock_ResetBytesWritten;
*GetAvgRead = *ZNCc::Csock_GetAvgRead;
*GetAvgWrite = *ZNCc::Csock_GetAvgWrite;
*GetRemotePort = *ZNCc::Csock_GetRemotePort;
*GetLocalPort = *ZNCc::Csock_GetLocalPort;
*GetPort = *ZNCc::Csock_GetPort;
*SetPort = *ZNCc::Csock_SetPort;
*Close = *ZNCc::Csock_Close;
*GetCloseType = *ZNCc::Csock_GetCloseType;
*IsClosed = *ZNCc::Csock_IsClosed;
*NonBlockingIO = *ZNCc::Csock_NonBlockingIO;
*GetSSL = *ZNCc::Csock_GetSSL;
*SetSSL = *ZNCc::Csock_SetSSL;
*GetWriteBuffer = *ZNCc::Csock_GetWriteBuffer;
*ClearWriteBuffer = *ZNCc::Csock_ClearWriteBuffer;
*SslIsEstablished = *ZNCc::Csock_SslIsEstablished;
*ConnectInetd = *ZNCc::Csock_ConnectInetd;
*ConnectFD = *ZNCc::Csock_ConnectFD;
*SetParentSockName = *ZNCc::Csock_SetParentSockName;
*GetParentSockName = *ZNCc::Csock_GetParentSockName;
*SetRate = *ZNCc::Csock_SetRate;
*GetRateBytes = *ZNCc::Csock_GetRateBytes;
*GetRateTime = *ZNCc::Csock_GetRateTime;
*Connected = *ZNCc::Csock_Connected;
*Disconnected = *ZNCc::Csock_Disconnected;
*Timeout = *ZNCc::Csock_Timeout;
*ReadData = *ZNCc::Csock_ReadData;
*ReadLine = *ZNCc::Csock_ReadLine;
*EnableReadLine = *ZNCc::Csock_EnableReadLine;
*DisableReadLine = *ZNCc::Csock_DisableReadLine;
*HasReadLine = *ZNCc::Csock_HasReadLine;
*ReachedMaxBuffer = *ZNCc::Csock_ReachedMaxBuffer;
*SockError = *ZNCc::Csock_SockError;
*ConnectionFrom = *ZNCc::Csock_ConnectionFrom;
*Listening = *ZNCc::Csock_Listening;
*ConnectionRefused = *ZNCc::Csock_ConnectionRefused;
*ReadPaused = *ZNCc::Csock_ReadPaused;
*GetTimeSinceLastDataTransaction = *ZNCc::Csock_GetTimeSinceLastDataTransaction;
*GetLastCheckTimeout = *ZNCc::Csock_GetLastCheckTimeout;
*GetNextCheckTimeout = *ZNCc::Csock_GetNextCheckTimeout;
*GetPending = *ZNCc::Csock_GetPending;
*GetConState = *ZNCc::Csock_GetConState;
*SetConState = *ZNCc::Csock_SetConState;
*CreateSocksFD = *ZNCc::Csock_CreateSocksFD;
*CloseSocksFD = *ZNCc::Csock_CloseSocksFD;
*GetBindHost = *ZNCc::Csock_GetBindHost;
*SetBindHost = *ZNCc::Csock_SetBindHost;
*DNS_VHOST = *ZNCc::Csock_DNS_VHOST;
*DNS_DEST = *ZNCc::Csock_DNS_DEST;
*DNSLookup = *ZNCc::Csock_DNSLookup;
*SetupVHost = *ZNCc::Csock_SetupVHost;
*GetIPv6 = *ZNCc::Csock_GetIPv6;
*SetIPv6 = *ZNCc::Csock_SetIPv6;
*SetAFRequire = *ZNCc::Csock_SetAFRequire;
*AllowWrite = *ZNCc::Csock_AllowWrite;
*SetSkipConnect = *ZNCc::Csock_SetSkipConnect;
*GetAddrInfo = *ZNCc::Csock_GetAddrInfo;
*ConvertAddress = *ZNCc::Csock_ConvertAddress;
*GetMaxConns = *ZNCc::Csock_GetMaxConns;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSConnection ##############

package ZNC::CSConnection;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSConnection(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSConnection($self);
        delete $OWNER{$self};
    }
}

*GetHostname = *ZNCc::CSConnection_GetHostname;
*GetSockName = *ZNCc::CSConnection_GetSockName;
*GetBindHost = *ZNCc::CSConnection_GetBindHost;
*GetPort = *ZNCc::CSConnection_GetPort;
*GetTimeout = *ZNCc::CSConnection_GetTimeout;
*GetIsSSL = *ZNCc::CSConnection_GetIsSSL;
*GetAFRequire = *ZNCc::CSConnection_GetAFRequire;
*SetHostname = *ZNCc::CSConnection_SetHostname;
*SetSockName = *ZNCc::CSConnection_SetSockName;
*SetBindHost = *ZNCc::CSConnection_SetBindHost;
*SetPort = *ZNCc::CSConnection_SetPort;
*SetTimeout = *ZNCc::CSConnection_SetTimeout;
*SetIsSSL = *ZNCc::CSConnection_SetIsSSL;
*SetAFRequire = *ZNCc::CSConnection_SetAFRequire;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSSSLConnection ##############

package ZNC::CSSSLConnection;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CSConnection ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSSSLConnection(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSSSLConnection($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSListener ##############

package ZNC::CSListener;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSListener(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSListener($self);
        delete $OWNER{$self};
    }
}

*SetDetach = *ZNCc::CSListener_SetDetach;
*GetDetach = *ZNCc::CSListener_GetDetach;
*GetPort = *ZNCc::CSListener_GetPort;
*GetSockName = *ZNCc::CSListener_GetSockName;
*GetBindHost = *ZNCc::CSListener_GetBindHost;
*GetIsSSL = *ZNCc::CSListener_GetIsSSL;
*GetMaxConns = *ZNCc::CSListener_GetMaxConns;
*GetTimeout = *ZNCc::CSListener_GetTimeout;
*GetAFRequire = *ZNCc::CSListener_GetAFRequire;
*SetPort = *ZNCc::CSListener_SetPort;
*SetSockName = *ZNCc::CSListener_SetSockName;
*SetBindHost = *ZNCc::CSListener_SetBindHost;
*SetIsSSL = *ZNCc::CSListener_SetIsSSL;
*SetMaxConns = *ZNCc::CSListener_SetMaxConns;
*SetTimeout = *ZNCc::CSListener_SetTimeout;
*SetAFRequire = *ZNCc::CSListener_SetAFRequire;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSocketManager ##############

package ZNC::CSocketManager;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CSockCommon ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSocketManager(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSocketManager($self);
        delete $OWNER{$self};
    }
}

*clear = *ZNCc::CSocketManager_clear;
*Cleanup = *ZNCc::CSocketManager_Cleanup;
*GetSockObj = *ZNCc::CSocketManager_GetSockObj;
*SUCCESS = *ZNCc::CSocketManager_SUCCESS;
*SELECT_ERROR = *ZNCc::CSocketManager_SELECT_ERROR;
*SELECT_TIMEOUT = *ZNCc::CSocketManager_SELECT_TIMEOUT;
*SELECT_TRYAGAIN = *ZNCc::CSocketManager_SELECT_TRYAGAIN;
*Connect = *ZNCc::CSocketManager_Connect;
*Listen = *ZNCc::CSocketManager_Listen;
*HasFDs = *ZNCc::CSocketManager_HasFDs;
*Loop = *ZNCc::CSocketManager_Loop;
*DynamicSelectLoop = *ZNCc::CSocketManager_DynamicSelectLoop;
*AddSock = *ZNCc::CSocketManager_AddSock;
*FindSockByRemotePort = *ZNCc::CSocketManager_FindSockByRemotePort;
*FindSockByLocalPort = *ZNCc::CSocketManager_FindSockByLocalPort;
*FindSockByName = *ZNCc::CSocketManager_FindSockByName;
*FindSockByFD = *ZNCc::CSocketManager_FindSockByFD;
*FindSocksByName = *ZNCc::CSocketManager_FindSocksByName;
*FindSocksByRemoteHost = *ZNCc::CSocketManager_FindSocksByRemoteHost;
*GetErrno = *ZNCc::CSocketManager_GetErrno;
*GetSelectTimeout = *ZNCc::CSocketManager_GetSelectTimeout;
*SetSelectTimeout = *ZNCc::CSocketManager_SetSelectTimeout;
*DelSockByAddr = *ZNCc::CSocketManager_DelSockByAddr;
*DelSock = *ZNCc::CSocketManager_DelSock;
*SwapSockByIdx = *ZNCc::CSocketManager_SwapSockByIdx;
*SwapSockByAddr = *ZNCc::CSocketManager_SwapSockByAddr;
*GetBytesRead = *ZNCc::CSocketManager_GetBytesRead;
*GetBytesWritten = *ZNCc::CSocketManager_GetBytesWritten;
*ECT_Read = *ZNCc::CSocketManager_ECT_Read;
*ECT_Write = *ZNCc::CSocketManager_ECT_Write;
*FDSetCheck = *ZNCc::CSocketManager_FDSetCheck;
*FDHasCheck = *ZNCc::CSocketManager_FDHasCheck;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::ZNCSocketManager ##############

package ZNC::ZNCSocketManager;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CSocketManager ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_ZNCSocketManager(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_ZNCSocketManager($self);
        delete $OWNER{$self};
    }
}

*GetSockObj = *ZNCc::ZNCSocketManager_GetSockObj;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CZNCSock ##############

package ZNC::CZNCSock;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::Csock ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CZNCSock(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CZNCSock($self);
        delete $OWNER{$self};
    }
}

*ConvertAddress = *ZNCc::CZNCSock_ConvertAddress;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSockManager ##############

package ZNC::CSockManager;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::ZNCSocketManager ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSockManager(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSockManager($self);
        delete $OWNER{$self};
    }
}

*ListenHost = *ZNCc::CSockManager_ListenHost;
*ListenAll = *ZNCc::CSockManager_ListenAll;
*ListenRand = *ZNCc::CSockManager_ListenRand;
*ListenAllRand = *ZNCc::CSockManager_ListenAllRand;
*Connect = *ZNCc::CSockManager_Connect;
*GetAnonConnectionCount = *ZNCc::CSockManager_GetAnonConnectionCount;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CSocket ##############

package ZNC::CSocket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CZNCSock ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CSocket(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CSocket($self);
        delete $OWNER{$self};
    }
}

*ReachedMaxBuffer = *ZNCc::CSocket_ReachedMaxBuffer;
*SockError = *ZNCc::CSocket_SockError;
*ConnectionFrom = *ZNCc::CSocket_ConnectionFrom;
*Connect = *ZNCc::CSocket_Connect;
*Listen = *ZNCc::CSocket_Listen;
*GetModule = *ZNCc::CSocket_GetModule;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CFile ##############

package ZNC::CFile;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CFile(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CFile($self);
        delete $OWNER{$self};
    }
}

*FT_REGULAR = *ZNCc::CFile_FT_REGULAR;
*FT_DIRECTORY = *ZNCc::CFile_FT_DIRECTORY;
*FT_CHARACTER = *ZNCc::CFile_FT_CHARACTER;
*FT_BLOCK = *ZNCc::CFile_FT_BLOCK;
*FT_FIFO = *ZNCc::CFile_FT_FIFO;
*FT_LINK = *ZNCc::CFile_FT_LINK;
*FT_SOCK = *ZNCc::CFile_FT_SOCK;
*SetFileName = *ZNCc::CFile_SetFileName;
*IsReg = *ZNCc::CFile_IsReg;
*IsDir = *ZNCc::CFile_IsDir;
*IsChr = *ZNCc::CFile_IsChr;
*IsBlk = *ZNCc::CFile_IsBlk;
*IsFifo = *ZNCc::CFile_IsFifo;
*IsLnk = *ZNCc::CFile_IsLnk;
*IsSock = *ZNCc::CFile_IsSock;
*FType = *ZNCc::CFile_FType;
*FA_Name = *ZNCc::CFile_FA_Name;
*FA_Size = *ZNCc::CFile_FA_Size;
*FA_ATime = *ZNCc::CFile_FA_ATime;
*FA_MTime = *ZNCc::CFile_FA_MTime;
*FA_CTime = *ZNCc::CFile_FA_CTime;
*FA_UID = *ZNCc::CFile_FA_UID;
*Exists = *ZNCc::CFile_Exists;
*GetSize = *ZNCc::CFile_GetSize;
*GetATime = *ZNCc::CFile_GetATime;
*GetMTime = *ZNCc::CFile_GetMTime;
*GetCTime = *ZNCc::CFile_GetCTime;
*GetUID = *ZNCc::CFile_GetUID;
*GetGID = *ZNCc::CFile_GetGID;
*GetInfo = *ZNCc::CFile_GetInfo;
*Delete = *ZNCc::CFile_Delete;
*Move = *ZNCc::CFile_Move;
*Copy = *ZNCc::CFile_Copy;
*Chmod = *ZNCc::CFile_Chmod;
*Seek = *ZNCc::CFile_Seek;
*Truncate = *ZNCc::CFile_Truncate;
*Sync = *ZNCc::CFile_Sync;
*Open = *ZNCc::CFile_Open;
*Read = *ZNCc::CFile_Read;
*ReadLine = *ZNCc::CFile_ReadLine;
*ReadFile = *ZNCc::CFile_ReadFile;
*Write = *ZNCc::CFile_Write;
*Close = *ZNCc::CFile_Close;
*ClearBuffer = *ZNCc::CFile_ClearBuffer;
*TryExLock = *ZNCc::CFile_TryExLock;
*ExLock = *ZNCc::CFile_ExLock;
*UnLock = *ZNCc::CFile_UnLock;
*IsOpen = *ZNCc::CFile_IsOpen;
*GetLongName = *ZNCc::CFile_GetLongName;
*GetShortName = *ZNCc::CFile_GetShortName;
*GetDir = *ZNCc::CFile_GetDir;
*HadError = *ZNCc::CFile_HadError;
*ResetError = *ZNCc::CFile_ResetError;
*InitHomePath = *ZNCc::CFile_InitHomePath;
*GetHomePath = *ZNCc::CFile_GetHomePath;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CDir ##############

package ZNC::CDir;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CDir(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CDir($self);
        delete $OWNER{$self};
    }
}

*CleanUp = *ZNCc::CDir_CleanUp;
*Fill = *ZNCc::CDir_Fill;
*FillByWildcard = *ZNCc::CDir_FillByWildcard;
*Chmod = *ZNCc::CDir_Chmod;
*Delete = *ZNCc::CDir_Delete;
*GetSortAttr = *ZNCc::CDir_GetSortAttr;
*IsDescending = *ZNCc::CDir_IsDescending;
*CheckPathPrefix = *ZNCc::CDir_CheckPathPrefix;
*ChangeDir = *ZNCc::CDir_ChangeDir;
*MakeDir = *ZNCc::CDir_MakeDir;
*GetCWD = *ZNCc::CDir_GetCWD;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CTimer ##############

package ZNC::CTimer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CCron ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CTimer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CTimer($self);
        delete $OWNER{$self};
    }
}

*SetModule = *ZNCc::CTimer_SetModule;
*SetDescription = *ZNCc::CTimer_SetDescription;
*GetModule = *ZNCc::CTimer_GetModule;
*GetDescription = *ZNCc::CTimer_GetDescription;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CFPTimer ##############

package ZNC::CFPTimer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CTimer ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CFPTimer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CFPTimer($self);
        delete $OWNER{$self};
    }
}

*SetFPCallback = *ZNCc::CFPTimer_SetFPCallback;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CModInfo ##############

package ZNC::CModInfo;
use overload
    "<" => sub { $_[0]->__lt__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
*GlobalModule = *ZNCc::CModInfo_GlobalModule;
*UserModule = *ZNCc::CModInfo_UserModule;
*NetworkModule = *ZNCc::CModInfo_NetworkModule;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CModInfo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CModInfo($self);
        delete $OWNER{$self};
    }
}

*__lt__ = *ZNCc::CModInfo___lt__;
*SupportsType = *ZNCc::CModInfo_SupportsType;
*AddType = *ZNCc::CModInfo_AddType;
*ModuleTypeToString = *ZNCc::CModInfo_ModuleTypeToString;
*GetName = *ZNCc::CModInfo_GetName;
*GetPath = *ZNCc::CModInfo_GetPath;
*GetDescription = *ZNCc::CModInfo_GetDescription;
*GetWikiPage = *ZNCc::CModInfo_GetWikiPage;
*GetArgsHelpText = *ZNCc::CModInfo_GetArgsHelpText;
*GetHasArgs = *ZNCc::CModInfo_GetHasArgs;
*GetLoader = *ZNCc::CModInfo_GetLoader;
*GetDefaultType = *ZNCc::CModInfo_GetDefaultType;
*SetName = *ZNCc::CModInfo_SetName;
*SetPath = *ZNCc::CModInfo_SetPath;
*SetDescription = *ZNCc::CModInfo_SetDescription;
*SetWikiPage = *ZNCc::CModInfo_SetWikiPage;
*SetArgsHelpText = *ZNCc::CModInfo_SetArgsHelpText;
*SetHasArgs = *ZNCc::CModInfo_SetHasArgs;
*SetLoader = *ZNCc::CModInfo_SetLoader;
*SetDefaultType = *ZNCc::CModInfo_SetDefaultType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CModCommand ##############

package ZNC::CModCommand;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CModCommand(@_);
    bless $self, $pkg if defined($self);
}

*InitHelp = *ZNCc::CModCommand_InitHelp;
*AddHelp = *ZNCc::CModCommand_AddHelp;
*GetCommand = *ZNCc::CModCommand_GetCommand;
*GetFunction = *ZNCc::CModCommand_GetFunction;
*GetArgs = *ZNCc::CModCommand_GetArgs;
*GetDescription = *ZNCc::CModCommand_GetDescription;
*Call = *ZNCc::CModCommand_Call;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CModCommand($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CModule ##############

package ZNC::CModule;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CModule(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CModule($self);
        delete $OWNER{$self};
    }
}

*CONTINUE = *ZNCc::CModule_CONTINUE;
*HALT = *ZNCc::CModule_HALT;
*HALTMODS = *ZNCc::CModule_HALTMODS;
*HALTCORE = *ZNCc::CModule_HALTCORE;
*UNLOAD = *ZNCc::CModule_UNLOAD;
*SetUser = *ZNCc::CModule_SetUser;
*SetNetwork = *ZNCc::CModule_SetNetwork;
*SetClient = *ZNCc::CModule_SetClient;
*Unload = *ZNCc::CModule_Unload;
*OnLoad = *ZNCc::CModule_OnLoad;
*OnBoot = *ZNCc::CModule_OnBoot;
*WebRequiresLogin = *ZNCc::CModule_WebRequiresLogin;
*WebRequiresAdmin = *ZNCc::CModule_WebRequiresAdmin;
*GetWebMenuTitle = *ZNCc::CModule_GetWebMenuTitle;
*GetWebPath = *ZNCc::CModule_GetWebPath;
*GetWebFilesPath = *ZNCc::CModule_GetWebFilesPath;
*OnWebPreRequest = *ZNCc::CModule_OnWebPreRequest;
*OnWebRequest = *ZNCc::CModule_OnWebRequest;
*AddSubPage = *ZNCc::CModule_AddSubPage;
*ClearSubPages = *ZNCc::CModule_ClearSubPages;
*GetSubPages = *ZNCc::CModule_GetSubPages;
*OnEmbeddedWebRequest = *ZNCc::CModule_OnEmbeddedWebRequest;
*OnPreRehash = *ZNCc::CModule_OnPreRehash;
*OnPostRehash = *ZNCc::CModule_OnPostRehash;
*OnIRCDisconnected = *ZNCc::CModule_OnIRCDisconnected;
*OnIRCConnected = *ZNCc::CModule_OnIRCConnected;
*OnIRCConnecting = *ZNCc::CModule_OnIRCConnecting;
*OnIRCConnectionError = *ZNCc::CModule_OnIRCConnectionError;
*OnIRCRegistration = *ZNCc::CModule_OnIRCRegistration;
*OnBroadcast = *ZNCc::CModule_OnBroadcast;
*OnChanPermission = *ZNCc::CModule_OnChanPermission;
*OnOp = *ZNCc::CModule_OnOp;
*OnDeop = *ZNCc::CModule_OnDeop;
*OnVoice = *ZNCc::CModule_OnVoice;
*OnDevoice = *ZNCc::CModule_OnDevoice;
*OnMode = *ZNCc::CModule_OnMode;
*OnRawMode = *ZNCc::CModule_OnRawMode;
*OnRaw = *ZNCc::CModule_OnRaw;
*OnStatusCommand = *ZNCc::CModule_OnStatusCommand;
*OnModCommand = *ZNCc::CModule_OnModCommand;
*OnUnknownModCommand = *ZNCc::CModule_OnUnknownModCommand;
*OnModNotice = *ZNCc::CModule_OnModNotice;
*OnModCTCP = *ZNCc::CModule_OnModCTCP;
*OnQuit = *ZNCc::CModule_OnQuit;
*OnNick = *ZNCc::CModule_OnNick;
*OnKick = *ZNCc::CModule_OnKick;
*OnJoin = *ZNCc::CModule_OnJoin;
*OnPart = *ZNCc::CModule_OnPart;
*OnInvite = *ZNCc::CModule_OnInvite;
*OnChanBufferStarting = *ZNCc::CModule_OnChanBufferStarting;
*OnChanBufferEnding = *ZNCc::CModule_OnChanBufferEnding;
*OnChanBufferPlayLine = *ZNCc::CModule_OnChanBufferPlayLine;
*OnPrivBufferPlayLine = *ZNCc::CModule_OnPrivBufferPlayLine;
*OnClientLogin = *ZNCc::CModule_OnClientLogin;
*OnClientDisconnect = *ZNCc::CModule_OnClientDisconnect;
*OnUserRaw = *ZNCc::CModule_OnUserRaw;
*OnUserCTCPReply = *ZNCc::CModule_OnUserCTCPReply;
*OnUserCTCP = *ZNCc::CModule_OnUserCTCP;
*OnUserAction = *ZNCc::CModule_OnUserAction;
*OnUserMsg = *ZNCc::CModule_OnUserMsg;
*OnUserNotice = *ZNCc::CModule_OnUserNotice;
*OnUserJoin = *ZNCc::CModule_OnUserJoin;
*OnUserPart = *ZNCc::CModule_OnUserPart;
*OnUserTopic = *ZNCc::CModule_OnUserTopic;
*OnUserTopicRequest = *ZNCc::CModule_OnUserTopicRequest;
*OnCTCPReply = *ZNCc::CModule_OnCTCPReply;
*OnPrivCTCP = *ZNCc::CModule_OnPrivCTCP;
*OnChanCTCP = *ZNCc::CModule_OnChanCTCP;
*OnPrivAction = *ZNCc::CModule_OnPrivAction;
*OnChanAction = *ZNCc::CModule_OnChanAction;
*OnPrivMsg = *ZNCc::CModule_OnPrivMsg;
*OnChanMsg = *ZNCc::CModule_OnChanMsg;
*OnPrivNotice = *ZNCc::CModule_OnPrivNotice;
*OnChanNotice = *ZNCc::CModule_OnChanNotice;
*OnTopic = *ZNCc::CModule_OnTopic;
*OnServerCapAvailable = *ZNCc::CModule_OnServerCapAvailable;
*OnServerCapResult = *ZNCc::CModule_OnServerCapResult;
*OnTimerAutoJoin = *ZNCc::CModule_OnTimerAutoJoin;
*OnAddNetwork = *ZNCc::CModule_OnAddNetwork;
*OnDeleteNetwork = *ZNCc::CModule_OnDeleteNetwork;
*GetDLL = *ZNCc::CModule_GetDLL;
*GetCoreVersion = *ZNCc::CModule_GetCoreVersion;
*PutIRC = *ZNCc::CModule_PutIRC;
*PutUser = *ZNCc::CModule_PutUser;
*PutStatus = *ZNCc::CModule_PutStatus;
*PutModule = *ZNCc::CModule_PutModule;
*PutModNotice = *ZNCc::CModule_PutModNotice;
*GetModName = *ZNCc::CModule_GetModName;
*GetModNick = *ZNCc::CModule_GetModNick;
*GetModDataDir = *ZNCc::CModule_GetModDataDir;
*AddTimer = *ZNCc::CModule_AddTimer;
*RemTimer = *ZNCc::CModule_RemTimer;
*UnlinkTimer = *ZNCc::CModule_UnlinkTimer;
*FindTimer = *ZNCc::CModule_FindTimer;
*BeginTimers = *ZNCc::CModule_BeginTimers;
*EndTimers = *ZNCc::CModule_EndTimers;
*ListTimers = *ZNCc::CModule_ListTimers;
*AddSocket = *ZNCc::CModule_AddSocket;
*RemSocket = *ZNCc::CModule_RemSocket;
*UnlinkSocket = *ZNCc::CModule_UnlinkSocket;
*FindSocket = *ZNCc::CModule_FindSocket;
*BeginSockets = *ZNCc::CModule_BeginSockets;
*EndSockets = *ZNCc::CModule_EndSockets;
*ListSockets = *ZNCc::CModule_ListSockets;
*AddHelpCommand = *ZNCc::CModule_AddHelpCommand;
*AddCommand = *ZNCc::CModule_AddCommand;
*RemCommand = *ZNCc::CModule_RemCommand;
*FindCommand = *ZNCc::CModule_FindCommand;
*HandleCommand = *ZNCc::CModule_HandleCommand;
*HandleHelpCommand = *ZNCc::CModule_HandleHelpCommand;
*LoadRegistry = *ZNCc::CModule_LoadRegistry;
*SaveRegistry = *ZNCc::CModule_SaveRegistry;
*SetNV = *ZNCc::CModule_SetNV;
*GetNV = *ZNCc::CModule_GetNV;
*FindNV = *ZNCc::CModule_FindNV;
*EndNV = *ZNCc::CModule_EndNV;
*BeginNV = *ZNCc::CModule_BeginNV;
*DelNV = *ZNCc::CModule_DelNV;
*ClearNV = *ZNCc::CModule_ClearNV;
*GetSavePath = *ZNCc::CModule_GetSavePath;
*ExpandString = *ZNCc::CModule_ExpandString;
*SetType = *ZNCc::CModule_SetType;
*SetDescription = *ZNCc::CModule_SetDescription;
*SetModPath = *ZNCc::CModule_SetModPath;
*SetArgs = *ZNCc::CModule_SetArgs;
*GetType = *ZNCc::CModule_GetType;
*GetDescription = *ZNCc::CModule_GetDescription;
*GetArgs = *ZNCc::CModule_GetArgs;
*GetModPath = *ZNCc::CModule_GetModPath;
*GetUser = *ZNCc::CModule_GetUser;
*GetNetwork = *ZNCc::CModule_GetNetwork;
*GetClient = *ZNCc::CModule_GetClient;
*GetManager = *ZNCc::CModule_GetManager;
*OnAddUser = *ZNCc::CModule_OnAddUser;
*OnDeleteUser = *ZNCc::CModule_OnDeleteUser;
*OnClientConnect = *ZNCc::CModule_OnClientConnect;
*OnLoginAttempt = *ZNCc::CModule_OnLoginAttempt;
*OnFailedLogin = *ZNCc::CModule_OnFailedLogin;
*OnUnknownUserRaw = *ZNCc::CModule_OnUnknownUserRaw;
*OnClientCapLs = *ZNCc::CModule_OnClientCapLs;
*IsClientCapSupported = *ZNCc::CModule_IsClientCapSupported;
*OnClientCapRequest = *ZNCc::CModule_OnClientCapRequest;
*OnModuleLoading = *ZNCc::CModule_OnModuleLoading;
*OnModuleUnloading = *ZNCc::CModule_OnModuleUnloading;
*OnGetModInfo = *ZNCc::CModule_OnGetModInfo;
*OnGetAvailableMods = *ZNCc::CModule_OnGetAvailableMods;
*_GetNVKeys = *ZNCc::CModule__GetNVKeys;
*ExistsNV = *ZNCc::CModule_ExistsNV;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CModules ##############

package ZNC::CModules;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CModules(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CModules($self);
        delete $OWNER{$self};
    }
}

*SetUser = *ZNCc::CModules_SetUser;
*SetNetwork = *ZNCc::CModules_SetNetwork;
*SetClient = *ZNCc::CModules_SetClient;
*GetUser = *ZNCc::CModules_GetUser;
*GetNetwork = *ZNCc::CModules_GetNetwork;
*GetClient = *ZNCc::CModules_GetClient;
*UnloadAll = *ZNCc::CModules_UnloadAll;
*OnBoot = *ZNCc::CModules_OnBoot;
*OnPreRehash = *ZNCc::CModules_OnPreRehash;
*OnPostRehash = *ZNCc::CModules_OnPostRehash;
*OnIRCDisconnected = *ZNCc::CModules_OnIRCDisconnected;
*OnIRCConnected = *ZNCc::CModules_OnIRCConnected;
*OnIRCConnecting = *ZNCc::CModules_OnIRCConnecting;
*OnIRCConnectionError = *ZNCc::CModules_OnIRCConnectionError;
*OnIRCRegistration = *ZNCc::CModules_OnIRCRegistration;
*OnBroadcast = *ZNCc::CModules_OnBroadcast;
*OnChanPermission = *ZNCc::CModules_OnChanPermission;
*OnOp = *ZNCc::CModules_OnOp;
*OnDeop = *ZNCc::CModules_OnDeop;
*OnVoice = *ZNCc::CModules_OnVoice;
*OnDevoice = *ZNCc::CModules_OnDevoice;
*OnRawMode = *ZNCc::CModules_OnRawMode;
*OnMode = *ZNCc::CModules_OnMode;
*OnRaw = *ZNCc::CModules_OnRaw;
*OnStatusCommand = *ZNCc::CModules_OnStatusCommand;
*OnModCommand = *ZNCc::CModules_OnModCommand;
*OnModNotice = *ZNCc::CModules_OnModNotice;
*OnModCTCP = *ZNCc::CModules_OnModCTCP;
*OnQuit = *ZNCc::CModules_OnQuit;
*OnNick = *ZNCc::CModules_OnNick;
*OnKick = *ZNCc::CModules_OnKick;
*OnJoin = *ZNCc::CModules_OnJoin;
*OnPart = *ZNCc::CModules_OnPart;
*OnInvite = *ZNCc::CModules_OnInvite;
*OnChanBufferStarting = *ZNCc::CModules_OnChanBufferStarting;
*OnChanBufferEnding = *ZNCc::CModules_OnChanBufferEnding;
*OnChanBufferPlayLine = *ZNCc::CModules_OnChanBufferPlayLine;
*OnPrivBufferPlayLine = *ZNCc::CModules_OnPrivBufferPlayLine;
*OnClientLogin = *ZNCc::CModules_OnClientLogin;
*OnClientDisconnect = *ZNCc::CModules_OnClientDisconnect;
*OnUserRaw = *ZNCc::CModules_OnUserRaw;
*OnUserCTCPReply = *ZNCc::CModules_OnUserCTCPReply;
*OnUserCTCP = *ZNCc::CModules_OnUserCTCP;
*OnUserAction = *ZNCc::CModules_OnUserAction;
*OnUserMsg = *ZNCc::CModules_OnUserMsg;
*OnUserNotice = *ZNCc::CModules_OnUserNotice;
*OnUserJoin = *ZNCc::CModules_OnUserJoin;
*OnUserPart = *ZNCc::CModules_OnUserPart;
*OnUserTopic = *ZNCc::CModules_OnUserTopic;
*OnUserTopicRequest = *ZNCc::CModules_OnUserTopicRequest;
*OnCTCPReply = *ZNCc::CModules_OnCTCPReply;
*OnPrivCTCP = *ZNCc::CModules_OnPrivCTCP;
*OnChanCTCP = *ZNCc::CModules_OnChanCTCP;
*OnPrivAction = *ZNCc::CModules_OnPrivAction;
*OnChanAction = *ZNCc::CModules_OnChanAction;
*OnPrivMsg = *ZNCc::CModules_OnPrivMsg;
*OnChanMsg = *ZNCc::CModules_OnChanMsg;
*OnPrivNotice = *ZNCc::CModules_OnPrivNotice;
*OnChanNotice = *ZNCc::CModules_OnChanNotice;
*OnTopic = *ZNCc::CModules_OnTopic;
*OnTimerAutoJoin = *ZNCc::CModules_OnTimerAutoJoin;
*OnAddNetwork = *ZNCc::CModules_OnAddNetwork;
*OnDeleteNetwork = *ZNCc::CModules_OnDeleteNetwork;
*OnServerCapAvailable = *ZNCc::CModules_OnServerCapAvailable;
*OnServerCapResult = *ZNCc::CModules_OnServerCapResult;
*FindModule = *ZNCc::CModules_FindModule;
*LoadModule = *ZNCc::CModules_LoadModule;
*UnloadModule = *ZNCc::CModules_UnloadModule;
*ReloadModule = *ZNCc::CModules_ReloadModule;
*GetModInfo = *ZNCc::CModules_GetModInfo;
*GetModPathInfo = *ZNCc::CModules_GetModPathInfo;
*GetAvailableMods = *ZNCc::CModules_GetAvailableMods;
*FindModPath = *ZNCc::CModules_FindModPath;
*GetModDirs = *ZNCc::CModules_GetModDirs;
*OnAddUser = *ZNCc::CModules_OnAddUser;
*OnDeleteUser = *ZNCc::CModules_OnDeleteUser;
*OnClientConnect = *ZNCc::CModules_OnClientConnect;
*OnLoginAttempt = *ZNCc::CModules_OnLoginAttempt;
*OnFailedLogin = *ZNCc::CModules_OnFailedLogin;
*OnUnknownUserRaw = *ZNCc::CModules_OnUnknownUserRaw;
*OnClientCapLs = *ZNCc::CModules_OnClientCapLs;
*IsClientCapSupported = *ZNCc::CModules_IsClientCapSupported;
*OnClientCapRequest = *ZNCc::CModules_OnClientCapRequest;
*OnModuleLoading = *ZNCc::CModules_OnModuleLoading;
*OnModuleUnloading = *ZNCc::CModules_OnModuleUnloading;
*OnGetModInfo = *ZNCc::CModules_OnGetModInfo;
*OnGetAvailableMods = *ZNCc::CModules_OnGetAvailableMods;
*push_back = *ZNCc::CModules_push_back;
*removeModule = *ZNCc::CModules_removeModule;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CNick ##############

package ZNC::CNick;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CNick(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CNick($self);
        delete $OWNER{$self};
    }
}

*Reset = *ZNCc::CNick_Reset;
*Parse = *ZNCc::CNick_Parse;
*GetHostMask = *ZNCc::CNick_GetHostMask;
*GetCommonChans = *ZNCc::CNick_GetCommonChans;
*NickEquals = *ZNCc::CNick_NickEquals;
*SetNetwork = *ZNCc::CNick_SetNetwork;
*SetNick = *ZNCc::CNick_SetNick;
*SetIdent = *ZNCc::CNick_SetIdent;
*SetHost = *ZNCc::CNick_SetHost;
*AddPerm = *ZNCc::CNick_AddPerm;
*RemPerm = *ZNCc::CNick_RemPerm;
*GetPermStr = *ZNCc::CNick_GetPermStr;
*GetPermChar = *ZNCc::CNick_GetPermChar;
*HasPerm = *ZNCc::CNick_HasPerm;
*GetNick = *ZNCc::CNick_GetNick;
*GetIdent = *ZNCc::CNick_GetIdent;
*GetHost = *ZNCc::CNick_GetHost;
*GetNickMask = *ZNCc::CNick_GetNickMask;
*Clone = *ZNCc::CNick_Clone;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CChan ##############

package ZNC::CChan;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
*Voice = *ZNCc::CChan_Voice;
*HalfOp = *ZNCc::CChan_HalfOp;
*Op = *ZNCc::CChan_Op;
*Admin = *ZNCc::CChan_Admin;
*Owner = *ZNCc::CChan_Owner;
*M_Private = *ZNCc::CChan_M_Private;
*M_Secret = *ZNCc::CChan_M_Secret;
*M_Moderated = *ZNCc::CChan_M_Moderated;
*M_InviteOnly = *ZNCc::CChan_M_InviteOnly;
*M_NoMessages = *ZNCc::CChan_M_NoMessages;
*M_OpTopic = *ZNCc::CChan_M_OpTopic;
*M_Limit = *ZNCc::CChan_M_Limit;
*M_Key = *ZNCc::CChan_M_Key;
*M_Op = *ZNCc::CChan_M_Op;
*M_Voice = *ZNCc::CChan_M_Voice;
*M_Ban = *ZNCc::CChan_M_Ban;
*M_Except = *ZNCc::CChan_M_Except;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CChan(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CChan($self);
        delete $OWNER{$self};
    }
}

*Reset = *ZNCc::CChan_Reset;
*ToConfig = *ZNCc::CChan_ToConfig;
*Clone = *ZNCc::CChan_Clone;
*Cycle = *ZNCc::CChan_Cycle;
*JoinUser = *ZNCc::CChan_JoinUser;
*DetachUser = *ZNCc::CChan_DetachUser;
*AttachUser = *ZNCc::CChan_AttachUser;
*OnWho = *ZNCc::CChan_OnWho;
*SetModes = *ZNCc::CChan_SetModes;
*ModeChange = *ZNCc::CChan_ModeChange;
*AddMode = *ZNCc::CChan_AddMode;
*RemMode = *ZNCc::CChan_RemMode;
*GetModeString = *ZNCc::CChan_GetModeString;
*GetModeForNames = *ZNCc::CChan_GetModeForNames;
*ClearNicks = *ZNCc::CChan_ClearNicks;
*FindNick = *ZNCc::CChan_FindNick;
*AddNicks = *ZNCc::CChan_AddNicks;
*AddNick = *ZNCc::CChan_AddNick;
*RemNick = *ZNCc::CChan_RemNick;
*ChangeNick = *ZNCc::CChan_ChangeNick;
*GetBuffer = *ZNCc::CChan_GetBuffer;
*GetBufferCount = *ZNCc::CChan_GetBufferCount;
*SetBufferCount = *ZNCc::CChan_SetBufferCount;
*AddBuffer = *ZNCc::CChan_AddBuffer;
*ClearBuffer = *ZNCc::CChan_ClearBuffer;
*SendBuffer = *ZNCc::CChan_SendBuffer;
*GetPermStr = *ZNCc::CChan_GetPermStr;
*HasPerm = *ZNCc::CChan_HasPerm;
*AddPerm = *ZNCc::CChan_AddPerm;
*RemPerm = *ZNCc::CChan_RemPerm;
*SetModeKnown = *ZNCc::CChan_SetModeKnown;
*SetIsOn = *ZNCc::CChan_SetIsOn;
*SetKey = *ZNCc::CChan_SetKey;
*SetTopic = *ZNCc::CChan_SetTopic;
*SetTopicOwner = *ZNCc::CChan_SetTopicOwner;
*SetTopicDate = *ZNCc::CChan_SetTopicDate;
*SetDefaultModes = *ZNCc::CChan_SetDefaultModes;
*SetAutoClearChanBuffer = *ZNCc::CChan_SetAutoClearChanBuffer;
*SetDetached = *ZNCc::CChan_SetDetached;
*SetInConfig = *ZNCc::CChan_SetInConfig;
*SetCreationDate = *ZNCc::CChan_SetCreationDate;
*Disable = *ZNCc::CChan_Disable;
*Enable = *ZNCc::CChan_Enable;
*IncJoinTries = *ZNCc::CChan_IncJoinTries;
*ResetJoinTries = *ZNCc::CChan_ResetJoinTries;
*IsModeKnown = *ZNCc::CChan_IsModeKnown;
*HasMode = *ZNCc::CChan_HasMode;
*GetOptions = *ZNCc::CChan_GetOptions;
*GetModeArg = *ZNCc::CChan_GetModeArg;
*GetPermCounts = *ZNCc::CChan_GetPermCounts;
*IsOn = *ZNCc::CChan_IsOn;
*GetName = *ZNCc::CChan_GetName;
*GetModes = *ZNCc::CChan_GetModes;
*GetKey = *ZNCc::CChan_GetKey;
*GetTopic = *ZNCc::CChan_GetTopic;
*GetTopicOwner = *ZNCc::CChan_GetTopicOwner;
*GetTopicDate = *ZNCc::CChan_GetTopicDate;
*GetDefaultModes = *ZNCc::CChan_GetDefaultModes;
*GetNicks = *ZNCc::CChan_GetNicks;
*GetNickCount = *ZNCc::CChan_GetNickCount;
*AutoClearChanBuffer = *ZNCc::CChan_AutoClearChanBuffer;
*IsDetached = *ZNCc::CChan_IsDetached;
*InConfig = *ZNCc::CChan_InConfig;
*GetCreationDate = *ZNCc::CChan_GetCreationDate;
*IsDisabled = *ZNCc::CChan_IsDisabled;
*GetJoinTries = *ZNCc::CChan_GetJoinTries;
*GetNicks_ = *ZNCc::CChan_GetNicks_;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CUser ##############

package ZNC::CUser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CUser(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CUser($self);
        delete $OWNER{$self};
    }
}

*ParseConfig = *ZNCc::CUser_ParseConfig;
*HASH_NONE = *ZNCc::CUser_HASH_NONE;
*HASH_MD5 = *ZNCc::CUser_HASH_MD5;
*HASH_SHA256 = *ZNCc::CUser_HASH_SHA256;
*HASH_DEFAULT = *ZNCc::CUser_HASH_DEFAULT;
*SaltedHash = *ZNCc::CUser_SaltedHash;
*ToConfig = *ZNCc::CUser_ToConfig;
*CheckPass = *ZNCc::CUser_CheckPass;
*AddAllowedHost = *ZNCc::CUser_AddAllowedHost;
*IsHostAllowed = *ZNCc::CUser_IsHostAllowed;
*IsValid = *ZNCc::CUser_IsValid;
*IsValidUserName = *ZNCc::CUser_IsValidUserName;
*MakeCleanUserName = *ZNCc::CUser_MakeCleanUserName;
*GetModules = *ZNCc::CUser_GetModules;
*DeleteNetwork = *ZNCc::CUser_DeleteNetwork;
*AddNetwork = *ZNCc::CUser_AddNetwork;
*RemoveNetwork = *ZNCc::CUser_RemoveNetwork;
*FindNetwork = *ZNCc::CUser_FindNetwork;
*GetNetworks = *ZNCc::CUser_GetNetworks;
*HasSpaceForNewNetwork = *ZNCc::CUser_HasSpaceForNewNetwork;
*PutUser = *ZNCc::CUser_PutUser;
*PutAllUser = *ZNCc::CUser_PutAllUser;
*PutStatus = *ZNCc::CUser_PutStatus;
*PutStatusNotice = *ZNCc::CUser_PutStatusNotice;
*PutModule = *ZNCc::CUser_PutModule;
*PutModNotice = *ZNCc::CUser_PutModNotice;
*IsUserAttached = *ZNCc::CUser_IsUserAttached;
*UserConnected = *ZNCc::CUser_UserConnected;
*UserDisconnected = *ZNCc::CUser_UserDisconnected;
*GetLocalDCCIP = *ZNCc::CUser_GetLocalDCCIP;
*ExpandString = *ZNCc::CUser_ExpandString;
*AddTimestamp = *ZNCc::CUser_AddTimestamp;
*CloneNetworks = *ZNCc::CUser_CloneNetworks;
*Clone = *ZNCc::CUser_Clone;
*BounceAllClients = *ZNCc::CUser_BounceAllClients;
*AddBytesRead = *ZNCc::CUser_AddBytesRead;
*AddBytesWritten = *ZNCc::CUser_AddBytesWritten;
*SetNick = *ZNCc::CUser_SetNick;
*SetAltNick = *ZNCc::CUser_SetAltNick;
*SetIdent = *ZNCc::CUser_SetIdent;
*SetRealName = *ZNCc::CUser_SetRealName;
*SetBindHost = *ZNCc::CUser_SetBindHost;
*SetDCCBindHost = *ZNCc::CUser_SetDCCBindHost;
*SetPass = *ZNCc::CUser_SetPass;
*SetMultiClients = *ZNCc::CUser_SetMultiClients;
*SetDenyLoadMod = *ZNCc::CUser_SetDenyLoadMod;
*SetAdmin = *ZNCc::CUser_SetAdmin;
*SetDenySetBindHost = *ZNCc::CUser_SetDenySetBindHost;
*SetStatusPrefix = *ZNCc::CUser_SetStatusPrefix;
*SetDefaultChanModes = *ZNCc::CUser_SetDefaultChanModes;
*SetQuitMsg = *ZNCc::CUser_SetQuitMsg;
*AddCTCPReply = *ZNCc::CUser_AddCTCPReply;
*DelCTCPReply = *ZNCc::CUser_DelCTCPReply;
*SetBufferCount = *ZNCc::CUser_SetBufferCount;
*SetAutoClearChanBuffer = *ZNCc::CUser_SetAutoClearChanBuffer;
*SetBeingDeleted = *ZNCc::CUser_SetBeingDeleted;
*SetTimestampFormat = *ZNCc::CUser_SetTimestampFormat;
*SetTimestampAppend = *ZNCc::CUser_SetTimestampAppend;
*SetTimestampPrepend = *ZNCc::CUser_SetTimestampPrepend;
*SetTimezone = *ZNCc::CUser_SetTimezone;
*SetJoinTries = *ZNCc::CUser_SetJoinTries;
*SetMaxJoins = *ZNCc::CUser_SetMaxJoins;
*SetSkinName = *ZNCc::CUser_SetSkinName;
*SetMaxNetworks = *ZNCc::CUser_SetMaxNetworks;
*GetUserClients = *ZNCc::CUser_GetUserClients;
*GetAllClients = *ZNCc::CUser_GetAllClients;
*GetUserName = *ZNCc::CUser_GetUserName;
*GetCleanUserName = *ZNCc::CUser_GetCleanUserName;
*GetNick = *ZNCc::CUser_GetNick;
*GetAltNick = *ZNCc::CUser_GetAltNick;
*GetIdent = *ZNCc::CUser_GetIdent;
*GetRealName = *ZNCc::CUser_GetRealName;
*GetBindHost = *ZNCc::CUser_GetBindHost;
*GetDCCBindHost = *ZNCc::CUser_GetDCCBindHost;
*GetPass = *ZNCc::CUser_GetPass;
*GetPassHashType = *ZNCc::CUser_GetPassHashType;
*GetPassSalt = *ZNCc::CUser_GetPassSalt;
*GetAllowedHosts = *ZNCc::CUser_GetAllowedHosts;
*GetTimestampFormat = *ZNCc::CUser_GetTimestampFormat;
*GetTimestampAppend = *ZNCc::CUser_GetTimestampAppend;
*GetTimestampPrepend = *ZNCc::CUser_GetTimestampPrepend;
*GetUserPath = *ZNCc::CUser_GetUserPath;
*DenyLoadMod = *ZNCc::CUser_DenyLoadMod;
*IsAdmin = *ZNCc::CUser_IsAdmin;
*DenySetBindHost = *ZNCc::CUser_DenySetBindHost;
*MultiClients = *ZNCc::CUser_MultiClients;
*GetStatusPrefix = *ZNCc::CUser_GetStatusPrefix;
*GetDefaultChanModes = *ZNCc::CUser_GetDefaultChanModes;
*GetQuitMsg = *ZNCc::CUser_GetQuitMsg;
*GetCTCPReplies = *ZNCc::CUser_GetCTCPReplies;
*GetBufferCount = *ZNCc::CUser_GetBufferCount;
*AutoClearChanBuffer = *ZNCc::CUser_AutoClearChanBuffer;
*IsBeingDeleted = *ZNCc::CUser_IsBeingDeleted;
*GetTimezone = *ZNCc::CUser_GetTimezone;
*BytesRead = *ZNCc::CUser_BytesRead;
*BytesWritten = *ZNCc::CUser_BytesWritten;
*JoinTries = *ZNCc::CUser_JoinTries;
*MaxJoins = *ZNCc::CUser_MaxJoins;
*GetSkinName = *ZNCc::CUser_GetSkinName;
*MaxNetworks = *ZNCc::CUser_MaxNetworks;
*GetNetworks_ = *ZNCc::CUser_GetNetworks_;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CIRCNetwork ##############

package ZNC::CIRCNetwork;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
*IsValidNetwork = *ZNCc::CIRCNetwork_IsValidNetwork;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CIRCNetwork(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CIRCNetwork($self);
        delete $OWNER{$self};
    }
}

*Clone = *ZNCc::CIRCNetwork_Clone;
*GetNetworkPath = *ZNCc::CIRCNetwork_GetNetworkPath;
*DelServers = *ZNCc::CIRCNetwork_DelServers;
*ParseConfig = *ZNCc::CIRCNetwork_ParseConfig;
*ToConfig = *ZNCc::CIRCNetwork_ToConfig;
*BounceAllClients = *ZNCc::CIRCNetwork_BounceAllClients;
*IsUserAttached = *ZNCc::CIRCNetwork_IsUserAttached;
*IsUserOnline = *ZNCc::CIRCNetwork_IsUserOnline;
*ClientConnected = *ZNCc::CIRCNetwork_ClientConnected;
*ClientDisconnected = *ZNCc::CIRCNetwork_ClientDisconnected;
*GetUser = *ZNCc::CIRCNetwork_GetUser;
*GetName = *ZNCc::CIRCNetwork_GetName;
*IsNetworkAttached = *ZNCc::CIRCNetwork_IsNetworkAttached;
*GetClients = *ZNCc::CIRCNetwork_GetClients;
*SetUser = *ZNCc::CIRCNetwork_SetUser;
*SetName = *ZNCc::CIRCNetwork_SetName;
*GetModules = *ZNCc::CIRCNetwork_GetModules;
*PutUser = *ZNCc::CIRCNetwork_PutUser;
*PutStatus = *ZNCc::CIRCNetwork_PutStatus;
*PutModule = *ZNCc::CIRCNetwork_PutModule;
*GetChans = *ZNCc::CIRCNetwork_GetChans;
*FindChan = *ZNCc::CIRCNetwork_FindChan;
*AddChan = *ZNCc::CIRCNetwork_AddChan;
*DelChan = *ZNCc::CIRCNetwork_DelChan;
*JoinChans = *ZNCc::CIRCNetwork_JoinChans;
*GetChanPrefixes = *ZNCc::CIRCNetwork_GetChanPrefixes;
*SetChanPrefixes = *ZNCc::CIRCNetwork_SetChanPrefixes;
*IsChan = *ZNCc::CIRCNetwork_IsChan;
*GetServers = *ZNCc::CIRCNetwork_GetServers;
*HasServers = *ZNCc::CIRCNetwork_HasServers;
*FindServer = *ZNCc::CIRCNetwork_FindServer;
*DelServer = *ZNCc::CIRCNetwork_DelServer;
*AddServer = *ZNCc::CIRCNetwork_AddServer;
*GetNextServer = *ZNCc::CIRCNetwork_GetNextServer;
*GetCurrentServer = *ZNCc::CIRCNetwork_GetCurrentServer;
*SetIRCServer = *ZNCc::CIRCNetwork_SetIRCServer;
*SetNextServer = *ZNCc::CIRCNetwork_SetNextServer;
*IsLastServer = *ZNCc::CIRCNetwork_IsLastServer;
*SetIRCConnectEnabled = *ZNCc::CIRCNetwork_SetIRCConnectEnabled;
*GetIRCConnectEnabled = *ZNCc::CIRCNetwork_GetIRCConnectEnabled;
*GetIRCSock = *ZNCc::CIRCNetwork_GetIRCSock;
*GetIRCServer = *ZNCc::CIRCNetwork_GetIRCServer;
*GetIRCNick = *ZNCc::CIRCNetwork_GetIRCNick;
*SetIRCNick = *ZNCc::CIRCNetwork_SetIRCNick;
*GetCurNick = *ZNCc::CIRCNetwork_GetCurNick;
*IsIRCAway = *ZNCc::CIRCNetwork_IsIRCAway;
*SetIRCAway = *ZNCc::CIRCNetwork_SetIRCAway;
*Connect = *ZNCc::CIRCNetwork_Connect;
*IsIRCConnected = *ZNCc::CIRCNetwork_IsIRCConnected;
*SetIRCSocket = *ZNCc::CIRCNetwork_SetIRCSocket;
*IRCDisconnected = *ZNCc::CIRCNetwork_IRCDisconnected;
*CheckIRCConnect = *ZNCc::CIRCNetwork_CheckIRCConnect;
*PutIRC = *ZNCc::CIRCNetwork_PutIRC;
*AddRawBuffer = *ZNCc::CIRCNetwork_AddRawBuffer;
*UpdateRawBuffer = *ZNCc::CIRCNetwork_UpdateRawBuffer;
*UpdateExactRawBuffer = *ZNCc::CIRCNetwork_UpdateExactRawBuffer;
*ClearRawBuffer = *ZNCc::CIRCNetwork_ClearRawBuffer;
*AddMotdBuffer = *ZNCc::CIRCNetwork_AddMotdBuffer;
*UpdateMotdBuffer = *ZNCc::CIRCNetwork_UpdateMotdBuffer;
*ClearMotdBuffer = *ZNCc::CIRCNetwork_ClearMotdBuffer;
*AddQueryBuffer = *ZNCc::CIRCNetwork_AddQueryBuffer;
*UpdateQueryBuffer = *ZNCc::CIRCNetwork_UpdateQueryBuffer;
*ClearQueryBuffer = *ZNCc::CIRCNetwork_ClearQueryBuffer;
*GetNick = *ZNCc::CIRCNetwork_GetNick;
*GetAltNick = *ZNCc::CIRCNetwork_GetAltNick;
*GetIdent = *ZNCc::CIRCNetwork_GetIdent;
*GetRealName = *ZNCc::CIRCNetwork_GetRealName;
*GetBindHost = *ZNCc::CIRCNetwork_GetBindHost;
*SetNick = *ZNCc::CIRCNetwork_SetNick;
*SetAltNick = *ZNCc::CIRCNetwork_SetAltNick;
*SetIdent = *ZNCc::CIRCNetwork_SetIdent;
*SetRealName = *ZNCc::CIRCNetwork_SetRealName;
*SetBindHost = *ZNCc::CIRCNetwork_SetBindHost;
*GetFloodRate = *ZNCc::CIRCNetwork_GetFloodRate;
*GetFloodBurst = *ZNCc::CIRCNetwork_GetFloodBurst;
*SetFloodRate = *ZNCc::CIRCNetwork_SetFloodRate;
*SetFloodBurst = *ZNCc::CIRCNetwork_SetFloodBurst;
*ExpandString = *ZNCc::CIRCNetwork_ExpandString;
*GetChans_ = *ZNCc::CIRCNetwork_GetChans_;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CAuthBase ##############

package ZNC::CAuthBase;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CAuthBase($self);
        delete $OWNER{$self};
    }
}

*SetLoginInfo = *ZNCc::CAuthBase_SetLoginInfo;
*AcceptLogin = *ZNCc::CAuthBase_AcceptLogin;
*RefuseLogin = *ZNCc::CAuthBase_RefuseLogin;
*GetUsername = *ZNCc::CAuthBase_GetUsername;
*GetPassword = *ZNCc::CAuthBase_GetPassword;
*GetSocket = *ZNCc::CAuthBase_GetSocket;
*GetRemoteIP = *ZNCc::CAuthBase_GetRemoteIP;
*Invalidate = *ZNCc::CAuthBase_Invalidate;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CClientAuth ##############

package ZNC::CClientAuth;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CAuthBase ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CClientAuth(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CClientAuth($self);
        delete $OWNER{$self};
    }
}

*Invalidate = *ZNCc::CClientAuth_Invalidate;
*AcceptedLogin = *ZNCc::CClientAuth_AcceptedLogin;
*RefusedLogin = *ZNCc::CClientAuth_RefusedLogin;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CClient ##############

package ZNC::CClient;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CZNCSock ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CClient(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CClient($self);
        delete $OWNER{$self};
    }
}

*SendRequiredPasswordNotice = *ZNCc::CClient_SendRequiredPasswordNotice;
*AcceptLogin = *ZNCc::CClient_AcceptLogin;
*RefuseLogin = *ZNCc::CClient_RefuseLogin;
*GetNick = *ZNCc::CClient_GetNick;
*GetNickMask = *ZNCc::CClient_GetNickMask;
*HasNamesx = *ZNCc::CClient_HasNamesx;
*HasUHNames = *ZNCc::CClient_HasUHNames;
*IsAway = *ZNCc::CClient_IsAway;
*HasServerTime = *ZNCc::CClient_HasServerTime;
*UserCommand = *ZNCc::CClient_UserCommand;
*UserPortCommand = *ZNCc::CClient_UserPortCommand;
*StatusCTCP = *ZNCc::CClient_StatusCTCP;
*BouncedOff = *ZNCc::CClient_BouncedOff;
*IsAttached = *ZNCc::CClient_IsAttached;
*PutIRC = *ZNCc::CClient_PutIRC;
*PutClient = *ZNCc::CClient_PutClient;
*PutStatus = *ZNCc::CClient_PutStatus;
*PutStatusNotice = *ZNCc::CClient_PutStatusNotice;
*PutModule = *ZNCc::CClient_PutModule;
*PutModNotice = *ZNCc::CClient_PutModNotice;
*IsCapEnabled = *ZNCc::CClient_IsCapEnabled;
*ReadLine = *ZNCc::CClient_ReadLine;
*SendMotd = *ZNCc::CClient_SendMotd;
*HelpUser = *ZNCc::CClient_HelpUser;
*AuthUser = *ZNCc::CClient_AuthUser;
*Connected = *ZNCc::CClient_Connected;
*Timeout = *ZNCc::CClient_Timeout;
*Disconnected = *ZNCc::CClient_Disconnected;
*ConnectionRefused = *ZNCc::CClient_ConnectionRefused;
*ReachedMaxBuffer = *ZNCc::CClient_ReachedMaxBuffer;
*SetNick = *ZNCc::CClient_SetNick;
*SetAway = *ZNCc::CClient_SetAway;
*GetUser = *ZNCc::CClient_GetUser;
*SetNetwork = *ZNCc::CClient_SetNetwork;
*GetNetwork = *ZNCc::CClient_GetNetwork;
*GetClients = *ZNCc::CClient_GetClients;
*GetIRCSock = *ZNCc::CClient_GetIRCSock;
*GetFullName = *ZNCc::CClient_GetFullName;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CIRCSock ##############

package ZNC::CIRCSock;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CZNCSock ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CIRCSock(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CIRCSock($self);
        delete $OWNER{$self};
    }
}

*ListArg = *ZNCc::CIRCSock_ListArg;
*HasArg = *ZNCc::CIRCSock_HasArg;
*ArgWhenSet = *ZNCc::CIRCSock_ArgWhenSet;
*NoArg = *ZNCc::CIRCSock_NoArg;
*OnCTCPReply = *ZNCc::CIRCSock_OnCTCPReply;
*OnPrivCTCP = *ZNCc::CIRCSock_OnPrivCTCP;
*OnChanCTCP = *ZNCc::CIRCSock_OnChanCTCP;
*OnGeneralCTCP = *ZNCc::CIRCSock_OnGeneralCTCP;
*OnPrivMsg = *ZNCc::CIRCSock_OnPrivMsg;
*OnChanMsg = *ZNCc::CIRCSock_OnChanMsg;
*OnPrivNotice = *ZNCc::CIRCSock_OnPrivNotice;
*OnChanNotice = *ZNCc::CIRCSock_OnChanNotice;
*OnServerCapAvailable = *ZNCc::CIRCSock_OnServerCapAvailable;
*ReadLine = *ZNCc::CIRCSock_ReadLine;
*Connected = *ZNCc::CIRCSock_Connected;
*Disconnected = *ZNCc::CIRCSock_Disconnected;
*ConnectionRefused = *ZNCc::CIRCSock_ConnectionRefused;
*SockError = *ZNCc::CIRCSock_SockError;
*Timeout = *ZNCc::CIRCSock_Timeout;
*ReachedMaxBuffer = *ZNCc::CIRCSock_ReachedMaxBuffer;
*PutIRC = *ZNCc::CIRCSock_PutIRC;
*PutIRCQuick = *ZNCc::CIRCSock_PutIRCQuick;
*ResetChans = *ZNCc::CIRCSock_ResetChans;
*Quit = *ZNCc::CIRCSock_Quit;
*PauseCap = *ZNCc::CIRCSock_PauseCap;
*ResumeCap = *ZNCc::CIRCSock_ResumeCap;
*SetPass = *ZNCc::CIRCSock_SetPass;
*GetMaxNickLen = *ZNCc::CIRCSock_GetMaxNickLen;
*GetModeType = *ZNCc::CIRCSock_GetModeType;
*GetPermFromMode = *ZNCc::CIRCSock_GetPermFromMode;
*GetChanModes = *ZNCc::CIRCSock_GetChanModes;
*IsPermChar = *ZNCc::CIRCSock_IsPermChar;
*IsPermMode = *ZNCc::CIRCSock_IsPermMode;
*GetPerms = *ZNCc::CIRCSock_GetPerms;
*GetPermModes = *ZNCc::CIRCSock_GetPermModes;
*GetNickMask = *ZNCc::CIRCSock_GetNickMask;
*GetNick = *ZNCc::CIRCSock_GetNick;
*GetPass = *ZNCc::CIRCSock_GetPass;
*GetNetwork = *ZNCc::CIRCSock_GetNetwork;
*HasNamesx = *ZNCc::CIRCSock_HasNamesx;
*HasUHNames = *ZNCc::CIRCSock_HasUHNames;
*GetUserModes = *ZNCc::CIRCSock_GetUserModes;
*IsAuthed = *ZNCc::CIRCSock_IsAuthed;
*IsCapAccepted = *ZNCc::CIRCSock_IsCapAccepted;
*GetISupport = *ZNCc::CIRCSock_GetISupport;
*ForwardRaw353 = *ZNCc::CIRCSock_ForwardRaw353;
*IsFloodProtected = *ZNCc::CIRCSock_IsFloodProtected;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CListener ##############

package ZNC::CListener;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
*ACCEPT_IRC = *ZNCc::CListener_ACCEPT_IRC;
*ACCEPT_HTTP = *ZNCc::CListener_ACCEPT_HTTP;
*ACCEPT_ALL = *ZNCc::CListener_ACCEPT_ALL;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CListener(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CListener($self);
        delete $OWNER{$self};
    }
}

*IsSSL = *ZNCc::CListener_IsSSL;
*GetAddrType = *ZNCc::CListener_GetAddrType;
*GetPort = *ZNCc::CListener_GetPort;
*GetBindHost = *ZNCc::CListener_GetBindHost;
*GetRealListener = *ZNCc::CListener_GetRealListener;
*GetAcceptType = *ZNCc::CListener_GetAcceptType;
*SetAcceptType = *ZNCc::CListener_SetAcceptType;
*Listen = *ZNCc::CListener_Listen;
*ResetRealListener = *ZNCc::CListener_ResetRealListener;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CRealListener ##############

package ZNC::CRealListener;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CZNCSock ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CRealListener(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CRealListener($self);
        delete $OWNER{$self};
    }
}

*ConnectionFrom = *ZNCc::CRealListener_ConnectionFrom;
*GetSockObj = *ZNCc::CRealListener_GetSockObj;
*SockError = *ZNCc::CRealListener_SockError;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CIncomingConnection ##############

package ZNC::CIncomingConnection;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CZNCSock ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CIncomingConnection(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CIncomingConnection($self);
        delete $OWNER{$self};
    }
}

*ReadLine = *ZNCc::CIncomingConnection_ReadLine;
*ReachedMaxBuffer = *ZNCc::CIncomingConnection_ReachedMaxBuffer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CHTTPSock ##############

package ZNC::CHTTPSock;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CSocket ZNC );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CHTTPSock($self);
        delete $OWNER{$self};
    }
}

*ReadData = *ZNCc::CHTTPSock_ReadData;
*ReadLine = *ZNCc::CHTTPSock_ReadLine;
*Connected = *ZNCc::CHTTPSock_Connected;
*GetSockObj = *ZNCc::CHTTPSock_GetSockObj;
*ForceLogin = *ZNCc::CHTTPSock_ForceLogin;
*OnLogin = *ZNCc::CHTTPSock_OnLogin;
*OnPageRequest = *ZNCc::CHTTPSock_OnPageRequest;
*PrintFile = *ZNCc::CHTTPSock_PrintFile;
*CheckPost = *ZNCc::CHTTPSock_CheckPost;
*SentHeader = *ZNCc::CHTTPSock_SentHeader;
*PrintHeader = *ZNCc::CHTTPSock_PrintHeader;
*AddHeader = *ZNCc::CHTTPSock_AddHeader;
*SetContentType = *ZNCc::CHTTPSock_SetContentType;
*PrintNotFound = *ZNCc::CHTTPSock_PrintNotFound;
*Redirect = *ZNCc::CHTTPSock_Redirect;
*PrintErrorPage = *ZNCc::CHTTPSock_PrintErrorPage;
*ParseParams = *ZNCc::CHTTPSock_ParseParams;
*ParseURI = *ZNCc::CHTTPSock_ParseURI;
*GetPage = *ZNCc::CHTTPSock_GetPage;
*GetDate = *ZNCc::CHTTPSock_GetDate;
*GetRequestCookie = *ZNCc::CHTTPSock_GetRequestCookie;
*SendCookie = *ZNCc::CHTTPSock_SendCookie;
*SetDocRoot = *ZNCc::CHTTPSock_SetDocRoot;
*SetLoggedIn = *ZNCc::CHTTPSock_SetLoggedIn;
*GetPath = *ZNCc::CHTTPSock_GetPath;
*IsLoggedIn = *ZNCc::CHTTPSock_IsLoggedIn;
*GetDocRoot = *ZNCc::CHTTPSock_GetDocRoot;
*GetUser = *ZNCc::CHTTPSock_GetUser;
*GetPass = *ZNCc::CHTTPSock_GetPass;
*GetParamString = *ZNCc::CHTTPSock_GetParamString;
*GetContentType = *ZNCc::CHTTPSock_GetContentType;
*IsPost = *ZNCc::CHTTPSock_IsPost;
*GetParam = *ZNCc::CHTTPSock_GetParam;
*GetRawParam = *ZNCc::CHTTPSock_GetRawParam;
*HasParam = *ZNCc::CHTTPSock_HasParam;
*GetParams = *ZNCc::CHTTPSock_GetParams;
*GetParamValues = *ZNCc::CHTTPSock_GetParamValues;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CTemplateTagHandler ##############

package ZNC::CTemplateTagHandler;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CTemplateTagHandler(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CTemplateTagHandler($self);
        delete $OWNER{$self};
    }
}

*HandleVar = *ZNCc::CTemplateTagHandler_HandleVar;
*HandleTag = *ZNCc::CTemplateTagHandler_HandleTag;
*HandleIf = *ZNCc::CTemplateTagHandler_HandleIf;
*HandleValue = *ZNCc::CTemplateTagHandler_HandleValue;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CTemplateOptions ##############

package ZNC::CTemplateOptions;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CTemplateOptions(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CTemplateOptions($self);
        delete $OWNER{$self};
    }
}

*Parse = *ZNCc::CTemplateOptions_Parse;
*GetEscapeFrom = *ZNCc::CTemplateOptions_GetEscapeFrom;
*GetEscapeTo = *ZNCc::CTemplateOptions_GetEscapeTo;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CTemplateLoopContext ##############

package ZNC::CTemplateLoopContext;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CTemplateLoopContext(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CTemplateLoopContext($self);
        delete $OWNER{$self};
    }
}

*SetHasData = *ZNCc::CTemplateLoopContext_SetHasData;
*SetName = *ZNCc::CTemplateLoopContext_SetName;
*SetRowIndex = *ZNCc::CTemplateLoopContext_SetRowIndex;
*IncRowIndex = *ZNCc::CTemplateLoopContext_IncRowIndex;
*DecRowIndex = *ZNCc::CTemplateLoopContext_DecRowIndex;
*SetFilePosition = *ZNCc::CTemplateLoopContext_SetFilePosition;
*HasData = *ZNCc::CTemplateLoopContext_HasData;
*GetName = *ZNCc::CTemplateLoopContext_GetName;
*GetFilePosition = *ZNCc::CTemplateLoopContext_GetFilePosition;
*GetRowIndex = *ZNCc::CTemplateLoopContext_GetRowIndex;
*GetRowCount = *ZNCc::CTemplateLoopContext_GetRowCount;
*GetRows = *ZNCc::CTemplateLoopContext_GetRows;
*GetNextRow = *ZNCc::CTemplateLoopContext_GetNextRow;
*GetCurRow = *ZNCc::CTemplateLoopContext_GetCurRow;
*GetRow = *ZNCc::CTemplateLoopContext_GetRow;
*GetValue = *ZNCc::CTemplateLoopContext_GetValue;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CTemplate ##############

package ZNC::CTemplate;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::MCString ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CTemplate(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CTemplate($self);
        delete $OWNER{$self};
    }
}

*AddTagHandler = *ZNCc::CTemplate_AddTagHandler;
*GetTagHandlers = *ZNCc::CTemplate_GetTagHandlers;
*ResolveLiteral = *ZNCc::CTemplate_ResolveLiteral;
*Init = *ZNCc::CTemplate_Init;
*GetParent = *ZNCc::CTemplate_GetParent;
*ExpandFile = *ZNCc::CTemplate_ExpandFile;
*SetFile = *ZNCc::CTemplate_SetFile;
*SetPath = *ZNCc::CTemplate_SetPath;
*MakePath = *ZNCc::CTemplate_MakePath;
*PrependPath = *ZNCc::CTemplate_PrependPath;
*AppendPath = *ZNCc::CTemplate_AppendPath;
*RemovePath = *ZNCc::CTemplate_RemovePath;
*ClearPaths = *ZNCc::CTemplate_ClearPaths;
*PrintString = *ZNCc::CTemplate_PrintString;
*Print = *ZNCc::CTemplate_Print;
*ValidIf = *ZNCc::CTemplate_ValidIf;
*ValidExpr = *ZNCc::CTemplate_ValidExpr;
*IsTrue = *ZNCc::CTemplate_IsTrue;
*HasLoop = *ZNCc::CTemplate_HasLoop;
*GetValue = *ZNCc::CTemplate_GetValue;
*AddRow = *ZNCc::CTemplate_AddRow;
*GetRow = *ZNCc::CTemplate_GetRow;
*GetLoop = *ZNCc::CTemplate_GetLoop;
*DelCurLoopContext = *ZNCc::CTemplate_DelCurLoopContext;
*GetCurLoopContext = *ZNCc::CTemplate_GetCurLoopContext;
*GetCurTemplate = *ZNCc::CTemplate_GetCurTemplate;
*GetFileName = *ZNCc::CTemplate_GetFileName;
*set = *ZNCc::CTemplate_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CZNCTagHandler ##############

package ZNC::CZNCTagHandler;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CTemplateTagHandler ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CZNCTagHandler(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CZNCTagHandler($self);
        delete $OWNER{$self};
    }
}

*HandleTag = *ZNCc::CZNCTagHandler_HandleTag;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CWebSession ##############

package ZNC::CWebSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CWebSession(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CWebSession($self);
        delete $OWNER{$self};
    }
}

*GetId = *ZNCc::CWebSession_GetId;
*GetIP = *ZNCc::CWebSession_GetIP;
*GetUser = *ZNCc::CWebSession_GetUser;
*IsLoggedIn = *ZNCc::CWebSession_IsLoggedIn;
*IsAdmin = *ZNCc::CWebSession_IsAdmin;
*SetUser = *ZNCc::CWebSession_SetUser;
*ClearMessageLoops = *ZNCc::CWebSession_ClearMessageLoops;
*FillMessageLoops = *ZNCc::CWebSession_FillMessageLoops;
*AddError = *ZNCc::CWebSession_AddError;
*AddSuccess = *ZNCc::CWebSession_AddSuccess;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CWebSubPage ##############

package ZNC::CWebSubPage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CWebSubPage(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CWebSubPage($self);
        delete $OWNER{$self};
    }
}

*F_ADMIN = *ZNCc::CWebSubPage_F_ADMIN;
*SetName = *ZNCc::CWebSubPage_SetName;
*SetTitle = *ZNCc::CWebSubPage_SetTitle;
*AddParam = *ZNCc::CWebSubPage_AddParam;
*RequiresAdmin = *ZNCc::CWebSubPage_RequiresAdmin;
*GetName = *ZNCc::CWebSubPage_GetName;
*GetTitle = *ZNCc::CWebSubPage_GetTitle;
*GetParams = *ZNCc::CWebSubPage_GetParams;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CWebSessionMap ##############

package ZNC::CWebSessionMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CWebSessionMap(@_);
    bless $self, $pkg if defined($self);
}

*FinishUserSessions = *ZNCc::CWebSessionMap_FinishUserSessions;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CWebSessionMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CWebSock ##############

package ZNC::CWebSock;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CHTTPSock ZNC );
%OWNER = ();
%ITERATORS = ();
*PAGE_NOTFOUND = *ZNCc::CWebSock_PAGE_NOTFOUND;
*PAGE_PRINT = *ZNCc::CWebSock_PAGE_PRINT;
*PAGE_DEFERRED = *ZNCc::CWebSock_PAGE_DEFERRED;
*PAGE_DONE = *ZNCc::CWebSock_PAGE_DONE;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CWebSock(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CWebSock($self);
        delete $OWNER{$self};
    }
}

*ForceLogin = *ZNCc::CWebSock_ForceLogin;
*OnLogin = *ZNCc::CWebSock_OnLogin;
*OnPageRequest = *ZNCc::CWebSock_OnPageRequest;
*PrintTemplate = *ZNCc::CWebSock_PrintTemplate;
*PrintStaticFile = *ZNCc::CWebSock_PrintStaticFile;
*FindTmpl = *ZNCc::CWebSock_FindTmpl;
*GetSession = *ZNCc::CWebSock_GetSession;
*GetSockObj = *ZNCc::CWebSock_GetSockObj;
*GetSkinPath = *ZNCc::CWebSock_GetSkinPath;
*GetModule = *ZNCc::CWebSock_GetModule;
*GetAvailSkins = *ZNCc::CWebSock_GetAvailSkins;
*GetSkinName = *ZNCc::CWebSock_GetSkinName;
*GetRequestCookie = *ZNCc::CWebSock_GetRequestCookie;
*SendCookie = *ZNCc::CWebSock_SendCookie;
*FinishUserSessions = *ZNCc::CWebSock_FinishUserSessions;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CZNC ##############

package ZNC::CZNC;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CZNC(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CZNC($self);
        delete $OWNER{$self};
    }
}

*ECONFIG_NOTHING = *ZNCc::CZNC_ECONFIG_NOTHING;
*ECONFIG_NEED_REHASH = *ZNCc::CZNC_ECONFIG_NEED_REHASH;
*ECONFIG_NEED_WRITE = *ZNCc::CZNC_ECONFIG_NEED_WRITE;
*DeleteUsers = *ZNCc::CZNC_DeleteUsers;
*Loop = *ZNCc::CZNC_Loop;
*WritePidFile = *ZNCc::CZNC_WritePidFile;
*DeletePidFile = *ZNCc::CZNC_DeletePidFile;
*WaitForChildLock = *ZNCc::CZNC_WaitForChildLock;
*IsHostAllowed = *ZNCc::CZNC_IsHostAllowed;
*AllowConnectionFrom = *ZNCc::CZNC_AllowConnectionFrom;
*InitDirs = *ZNCc::CZNC_InitDirs;
*OnBoot = *ZNCc::CZNC_OnBoot;
*ExpandConfigPath = *ZNCc::CZNC_ExpandConfigPath;
*WriteNewConfig = *ZNCc::CZNC_WriteNewConfig;
*WriteConfig = *ZNCc::CZNC_WriteConfig;
*ParseConfig = *ZNCc::CZNC_ParseConfig;
*RehashConfig = *ZNCc::CZNC_RehashConfig;
*BackupConfigOnce = *ZNCc::CZNC_BackupConfigOnce;
*GetVersion = *ZNCc::CZNC_GetVersion;
*GetTag = *ZNCc::CZNC_GetTag;
*GetCompileOptionsString = *ZNCc::CZNC_GetCompileOptionsString;
*GetUptime = *ZNCc::CZNC_GetUptime;
*ClearBindHosts = *ZNCc::CZNC_ClearBindHosts;
*AddBindHost = *ZNCc::CZNC_AddBindHost;
*RemBindHost = *ZNCc::CZNC_RemBindHost;
*Broadcast = *ZNCc::CZNC_Broadcast;
*AddBytesRead = *ZNCc::CZNC_AddBytesRead;
*AddBytesWritten = *ZNCc::CZNC_AddBytesWritten;
*BytesRead = *ZNCc::CZNC_BytesRead;
*BytesWritten = *ZNCc::CZNC_BytesWritten;
*GetTrafficStats = *ZNCc::CZNC_GetTrafficStats;
*AuthUser = *ZNCc::CZNC_AuthUser;
*SetConfigState = *ZNCc::CZNC_SetConfigState;
*SetSkinName = *ZNCc::CZNC_SetSkinName;
*SetStatusPrefix = *ZNCc::CZNC_SetStatusPrefix;
*SetMaxBufferSize = *ZNCc::CZNC_SetMaxBufferSize;
*SetAnonIPLimit = *ZNCc::CZNC_SetAnonIPLimit;
*SetServerThrottle = *ZNCc::CZNC_SetServerThrottle;
*SetProtectWebSessions = *ZNCc::CZNC_SetProtectWebSessions;
*SetConnectDelay = *ZNCc::CZNC_SetConnectDelay;
*GetConfigState = *ZNCc::CZNC_GetConfigState;
*GetManager = *ZNCc::CZNC_GetManager;
*GetModules = *ZNCc::CZNC_GetModules;
*FilterUncommonModules = *ZNCc::CZNC_FilterUncommonModules;
*GetSkinName = *ZNCc::CZNC_GetSkinName;
*GetStatusPrefix = *ZNCc::CZNC_GetStatusPrefix;
*GetCurPath = *ZNCc::CZNC_GetCurPath;
*GetHomePath = *ZNCc::CZNC_GetHomePath;
*GetZNCPath = *ZNCc::CZNC_GetZNCPath;
*GetConfPath = *ZNCc::CZNC_GetConfPath;
*GetUserPath = *ZNCc::CZNC_GetUserPath;
*GetModPath = *ZNCc::CZNC_GetModPath;
*GetPemLocation = *ZNCc::CZNC_GetPemLocation;
*GetConfigFile = *ZNCc::CZNC_GetConfigFile;
*WritePemFile = *ZNCc::CZNC_WritePemFile;
*GetBindHosts = *ZNCc::CZNC_GetBindHosts;
*GetListeners = *ZNCc::CZNC_GetListeners;
*TimeStarted = *ZNCc::CZNC_TimeStarted;
*GetMaxBufferSize = *ZNCc::CZNC_GetMaxBufferSize;
*GetAnonIPLimit = *ZNCc::CZNC_GetAnonIPLimit;
*GetConnectDelay = *ZNCc::CZNC_GetConnectDelay;
*GetProtectWebSessions = *ZNCc::CZNC_GetProtectWebSessions;
*Get = *ZNCc::CZNC_Get;
*FindUser = *ZNCc::CZNC_FindUser;
*FindModule = *ZNCc::CZNC_FindModule;
*UpdateModule = *ZNCc::CZNC_UpdateModule;
*DeleteUser = *ZNCc::CZNC_DeleteUser;
*AddUser = *ZNCc::CZNC_AddUser;
*GetUserMap = *ZNCc::CZNC_GetUserMap;
*FindListener = *ZNCc::CZNC_FindListener;
*AddListener = *ZNCc::CZNC_AddListener;
*DelListener = *ZNCc::CZNC_DelListener;
*SetMotd = *ZNCc::CZNC_SetMotd;
*AddMotd = *ZNCc::CZNC_AddMotd;
*ClearMotd = *ZNCc::CZNC_ClearMotd;
*GetMotd = *ZNCc::CZNC_GetMotd;
*AddServerThrottle = *ZNCc::CZNC_AddServerThrottle;
*GetServerThrottle = *ZNCc::CZNC_GetServerThrottle;
*AddNetworkToQueue = *ZNCc::CZNC_AddNetworkToQueue;
*GetConnectionQueue = *ZNCc::CZNC_GetConnectionQueue;
*EnableConnectQueue = *ZNCc::CZNC_EnableConnectQueue;
*DisableConnectQueue = *ZNCc::CZNC_DisableConnectQueue;
*PauseConnectQueue = *ZNCc::CZNC_PauseConnectQueue;
*ResumeConnectQueue = *ZNCc::CZNC_ResumeConnectQueue;
*LeakConnectQueueTimer = *ZNCc::CZNC_LeakConnectQueueTimer;
*DumpConfig = *ZNCc::CZNC_DumpConfig;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CServer ##############

package ZNC::CServer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CServer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CServer($self);
        delete $OWNER{$self};
    }
}

*GetName = *ZNCc::CServer_GetName;
*GetPort = *ZNCc::CServer_GetPort;
*GetPass = *ZNCc::CServer_GetPass;
*IsSSL = *ZNCc::CServer_IsSSL;
*GetString = *ZNCc::CServer_GetString;
*IsValidHostName = *ZNCc::CServer_IsValidHostName;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CDebug ##############

package ZNC::CDebug;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
*SetStdoutIsTTY = *ZNCc::CDebug_SetStdoutIsTTY;
*StdoutIsTTY = *ZNCc::CDebug_StdoutIsTTY;
*SetDebug = *ZNCc::CDebug_SetDebug;
*Debug = *ZNCc::CDebug_Debug;
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CDebug(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CDebug($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CDebugStream ##############

package ZNC::CDebugStream;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CDebugStream($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CDebugStream(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CExecSock ##############

package ZNC::CExecSock;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CZNCSock ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CExecSock(@_);
    bless $self, $pkg if defined($self);
}

*Execute = *ZNCc::CExecSock_Execute;
*Kill = *ZNCc::CExecSock_Kill;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CExecSock($self);
        delete $OWNER{$self};
    }
}

*popen2 = *ZNCc::CExecSock_popen2;
*close2 = *ZNCc::CExecSock_close2;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CBufLine ##############

package ZNC::CBufLine;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CBufLine(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CBufLine($self);
        delete $OWNER{$self};
    }
}

*GetLine = *ZNCc::CBufLine_GetLine;
*UpdateTime = *ZNCc::CBufLine_UpdateTime;
*SetFormat = *ZNCc::CBufLine_SetFormat;
*SetText = *ZNCc::CBufLine_SetText;
*SetTime = *ZNCc::CBufLine_SetTime;
*GetFormat = *ZNCc::CBufLine_GetFormat;
*GetText = *ZNCc::CBufLine_GetText;
*GetTime = *ZNCc::CBufLine_GetTime;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CBuffer ##############

package ZNC::CBuffer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CBuffer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CBuffer($self);
        delete $OWNER{$self};
    }
}

*AddLine = *ZNCc::CBuffer_AddLine;
*UpdateLine = *ZNCc::CBuffer_UpdateLine;
*UpdateExactLine = *ZNCc::CBuffer_UpdateExactLine;
*GetBufLine = *ZNCc::CBuffer_GetBufLine;
*GetLine = *ZNCc::CBuffer_GetLine;
*Size = *ZNCc::CBuffer_Size;
*IsEmpty = *ZNCc::CBuffer_IsEmpty;
*Clear = *ZNCc::CBuffer_Clear;
*SetLineCount = *ZNCc::CBuffer_SetLineCount;
*GetLineCount = *ZNCc::CBuffer_GetLineCount;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CPerlModule ##############

package ZNC::CPerlModule;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CModule ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CPerlModule(@_);
    bless $self, $pkg if defined($self);
}

*GetPerlObj = *ZNCc::CPerlModule_GetPerlObj;
*OnBoot = *ZNCc::CPerlModule_OnBoot;
*WebRequiresLogin = *ZNCc::CPerlModule_WebRequiresLogin;
*WebRequiresAdmin = *ZNCc::CPerlModule_WebRequiresAdmin;
*GetWebMenuTitle = *ZNCc::CPerlModule_GetWebMenuTitle;
*OnWebPreRequest = *ZNCc::CPerlModule_OnWebPreRequest;
*OnWebRequest = *ZNCc::CPerlModule_OnWebRequest;
*GetSubPages = *ZNCc::CPerlModule_GetSubPages;
*OnPreRehash = *ZNCc::CPerlModule_OnPreRehash;
*OnPostRehash = *ZNCc::CPerlModule_OnPostRehash;
*OnIRCDisconnected = *ZNCc::CPerlModule_OnIRCDisconnected;
*OnIRCConnected = *ZNCc::CPerlModule_OnIRCConnected;
*OnIRCConnecting = *ZNCc::CPerlModule_OnIRCConnecting;
*OnIRCConnectionError = *ZNCc::CPerlModule_OnIRCConnectionError;
*OnIRCRegistration = *ZNCc::CPerlModule_OnIRCRegistration;
*OnBroadcast = *ZNCc::CPerlModule_OnBroadcast;
*OnChanPermission = *ZNCc::CPerlModule_OnChanPermission;
*OnOp = *ZNCc::CPerlModule_OnOp;
*OnDeop = *ZNCc::CPerlModule_OnDeop;
*OnVoice = *ZNCc::CPerlModule_OnVoice;
*OnDevoice = *ZNCc::CPerlModule_OnDevoice;
*OnMode = *ZNCc::CPerlModule_OnMode;
*OnRawMode = *ZNCc::CPerlModule_OnRawMode;
*OnRaw = *ZNCc::CPerlModule_OnRaw;
*OnStatusCommand = *ZNCc::CPerlModule_OnStatusCommand;
*OnModCommand = *ZNCc::CPerlModule_OnModCommand;
*OnModNotice = *ZNCc::CPerlModule_OnModNotice;
*OnModCTCP = *ZNCc::CPerlModule_OnModCTCP;
*OnQuit = *ZNCc::CPerlModule_OnQuit;
*OnNick = *ZNCc::CPerlModule_OnNick;
*OnKick = *ZNCc::CPerlModule_OnKick;
*OnJoin = *ZNCc::CPerlModule_OnJoin;
*OnPart = *ZNCc::CPerlModule_OnPart;
*OnChanBufferStarting = *ZNCc::CPerlModule_OnChanBufferStarting;
*OnChanBufferEnding = *ZNCc::CPerlModule_OnChanBufferEnding;
*OnChanBufferPlayLine = *ZNCc::CPerlModule_OnChanBufferPlayLine;
*OnPrivBufferPlayLine = *ZNCc::CPerlModule_OnPrivBufferPlayLine;
*OnClientLogin = *ZNCc::CPerlModule_OnClientLogin;
*OnClientDisconnect = *ZNCc::CPerlModule_OnClientDisconnect;
*OnUserRaw = *ZNCc::CPerlModule_OnUserRaw;
*OnUserCTCPReply = *ZNCc::CPerlModule_OnUserCTCPReply;
*OnUserCTCP = *ZNCc::CPerlModule_OnUserCTCP;
*OnUserAction = *ZNCc::CPerlModule_OnUserAction;
*OnUserMsg = *ZNCc::CPerlModule_OnUserMsg;
*OnUserNotice = *ZNCc::CPerlModule_OnUserNotice;
*OnUserJoin = *ZNCc::CPerlModule_OnUserJoin;
*OnUserPart = *ZNCc::CPerlModule_OnUserPart;
*OnUserTopic = *ZNCc::CPerlModule_OnUserTopic;
*OnUserTopicRequest = *ZNCc::CPerlModule_OnUserTopicRequest;
*OnCTCPReply = *ZNCc::CPerlModule_OnCTCPReply;
*OnPrivCTCP = *ZNCc::CPerlModule_OnPrivCTCP;
*OnChanCTCP = *ZNCc::CPerlModule_OnChanCTCP;
*OnPrivAction = *ZNCc::CPerlModule_OnPrivAction;
*OnChanAction = *ZNCc::CPerlModule_OnChanAction;
*OnPrivMsg = *ZNCc::CPerlModule_OnPrivMsg;
*OnChanMsg = *ZNCc::CPerlModule_OnChanMsg;
*OnPrivNotice = *ZNCc::CPerlModule_OnPrivNotice;
*OnChanNotice = *ZNCc::CPerlModule_OnChanNotice;
*OnTopic = *ZNCc::CPerlModule_OnTopic;
*OnServerCapAvailable = *ZNCc::CPerlModule_OnServerCapAvailable;
*OnServerCapResult = *ZNCc::CPerlModule_OnServerCapResult;
*OnTimerAutoJoin = *ZNCc::CPerlModule_OnTimerAutoJoin;
*OnEmbeddedWebRequest = *ZNCc::CPerlModule_OnEmbeddedWebRequest;
*OnAddNetwork = *ZNCc::CPerlModule_OnAddNetwork;
*OnDeleteNetwork = *ZNCc::CPerlModule_OnDeleteNetwork;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CPerlModule($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CPerlTimer ##############

package ZNC::CPerlTimer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CTimer ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CPerlTimer(@_);
    bless $self, $pkg if defined($self);
}

*RunJob = *ZNCc::CPerlTimer_RunJob;
*GetPerlObj = *ZNCc::CPerlTimer_GetPerlObj;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CPerlTimer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::CPerlSocket ##############

package ZNC::CPerlSocket;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CSocket ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_CPerlSocket(@_);
    bless $self, $pkg if defined($self);
}

*GetPerlObj = *ZNCc::CPerlSocket_GetPerlObj;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_CPerlSocket($self);
        delete $OWNER{$self};
    }
}

*Connected = *ZNCc::CPerlSocket_Connected;
*Disconnected = *ZNCc::CPerlSocket_Disconnected;
*Timeout = *ZNCc::CPerlSocket_Timeout;
*ConnectionRefused = *ZNCc::CPerlSocket_ConnectionRefused;
*ReadData = *ZNCc::CPerlSocket_ReadData;
*ReadLine = *ZNCc::CPerlSocket_ReadLine;
*GetSockObj = *ZNCc::CPerlSocket_GetSockObj;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::String ##############

package ZNC::String;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC::CString ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_String(@_);
    bless $self, $pkg if defined($self);
}

*GetPerlStr = *ZNCc::String_GetPerlStr;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_String($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::StrPair ##############

package ZNC::StrPair;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_StrPair(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *ZNCc::StrPair_first_get;
*swig_first_set = *ZNCc::StrPair_first_set;
*swig_second_get = *ZNCc::StrPair_second_get;
*swig_second_set = *ZNCc::StrPair_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_StrPair($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::VPair ##############

package ZNC::VPair;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_VPair(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::VPair_size;
*empty = *ZNCc::VPair_empty;
*clear = *ZNCc::VPair_clear;
*push = *ZNCc::VPair_push;
*pop = *ZNCc::VPair_pop;
*get = *ZNCc::VPair_get;
*set = *ZNCc::VPair_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_VPair($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : ZNC::VWebSubPages ##############

package ZNC::VWebSubPages;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( ZNC );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = ZNCc::new_VWebSubPages(@_);
    bless $self, $pkg if defined($self);
}

*size = *ZNCc::VWebSubPages_size;
*empty = *ZNCc::VWebSubPages_empty;
*clear = *ZNCc::VWebSubPages_clear;
*push = *ZNCc::VWebSubPages_push;
*pop = *ZNCc::VWebSubPages_pop;
*get = *ZNCc::VWebSubPages_get;
*set = *ZNCc::VWebSubPages_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        ZNCc::delete_VWebSubPages($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package ZNC;

*g_HexDigits = *ZNCc::g_HexDigits;
*CS_INVALID_SOCK = *ZNCc::CS_INVALID_SOCK;
*CS_BLOCKSIZE = *ZNCc::CS_BLOCKSIZE;
*ADDR_IPV4ONLY = *ZNCc::ADDR_IPV4ONLY;
*ADDR_IPV6ONLY = *ZNCc::ADDR_IPV6ONLY;
*ADDR_ALL = *ZNCc::ADDR_ALL;
*Perl_NotFound = *ZNCc::Perl_NotFound;
*Perl_Loaded = *ZNCc::Perl_Loaded;
*Perl_LoadError = *ZNCc::Perl_LoadError;

	package ZNC::CModule;
	sub GetNVKeys {
		my $result = _GetNVKeys(@_);
		return @$result;
	}

	package ZNC;
	sub CreateWebSubPage {
		my ($name, %arg) = @_;
		my $params = $arg{params}//{};
		my $vpair = ZNC::VPair->new;
		while (my ($key, $val) = each %$params) {
			ZNC::_VPair_Add2Str($vpair, $key, $val);
		}
		my $flags = 0;
		$flags |= $ZNC::CWebSubPage::F_ADMIN if $arg{admin}//0;
		return _CreateWebSubPage($name, $arg{title}//'', $vpair, $flags);
	}

	package ZNC;
	*CONTINUE = *ZNC::CModule::CONTINUE;
	*HALT = *ZNC::CModule::HALT;
	*HALTMODS = *ZNC::CModule::HALTMODS;
	*HALTCORE = *ZNC::CModule::HALTCORE;
	*UNLOAD = *ZNC::CModule::UNLOAD;

	package ZNC::CIRCNetwork;
	*GetChans = *GetChans_;

	package ZNC::CUser;
	*GetNetworks = *GetNetworks_;

	package ZNC::CChan;
	sub _GetNicks_ {
		my $result = GetNicks_(@_);
		return %$result;
	}
	*GetNicks = *_GetNicks_;
1;
